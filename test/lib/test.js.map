{"version":3,"sources":["webpack:///webpack/bootstrap cca1404dc6ae3780792f","webpack:///./test/test.js","webpack:///./lib/axial.js","webpack:///./lib/const.js","webpack:///./~/expect/lib/index.js","webpack:///./~/expect/lib/Expectation.js","webpack:///./~/has/src/index.js","webpack:///./~/function-bind/index.js","webpack:///./~/function-bind/implementation.js","webpack:///./~/tmatch/index.js","webpack:///./~/process/browser.js","webpack:///./~/buffer/index.js","webpack:///./~/base64-js/index.js","webpack:///./~/ieee754/index.js","webpack:///./~/buffer/~/isarray/index.js","webpack:///./~/expect/lib/assert.js","webpack:///./~/object-inspect/index.js","webpack:///./~/expect/lib/SpyUtils.js","webpack:///./~/define-properties/index.js","webpack:///./~/object-keys/index.js","webpack:///./~/object-keys/isArguments.js","webpack:///./~/foreach/index.js","webpack:///./~/expect/lib/TestUtils.js","webpack:///./~/is-regex/index.js","webpack:///./~/is-equal/why.js","webpack:///./~/is-arrow-function/index.js","webpack:///./~/is-callable/index.js","webpack:///./~/is-boolean-object/index.js","webpack:///./~/is-date-object/index.js","webpack:///./~/is-generator-function/index.js","webpack:///./~/is-number-object/index.js","webpack:///./~/is-string/index.js","webpack:///./~/is-symbol/index.js","webpack:///./~/is-equal/getSymbolIterator.js","webpack:///./~/is-equal/getCollectionsForEach.js","webpack:///./~/expect/lib/extend.js"],"names":["Axial","require","util","expect","PROXY","PROXY_KEY","describe","it","typeOf","toBe","Null","undefined","Undefined","String","Number","Boolean","Date","Regex","Function","Array","Object","name","type","iface","a","define","x","y","z","toBeA","Interface","constructor","prop","is","v","w","toThrow","TypeAlreadyDefined","b","new","Instance","orNull","root","UnknownInterfaceKey","InvalidType","toNotThrow","c","d","extend","defaultValue","min","max","pattern","validator","value","Error","InvalidNumericType","InvalidStringPattern","handlerCount","fn","eventData","method","bind","unbind","test","ifaceA","ifaceB","IFace","instance","array","proxy","dispatch","e","arrayMethod","length","toEqual","copyWithin","fill","pop","push","reverse","shift","sort","round","splice","unshift","Item","text","List","items","list","validItem","invalidItem","foo","add","contains","remove","isEmpty","ifaceC","inst","set","who","has","super","module","exports","Define_Axial","CONST","BLANK_INTERFACE_NAME","_arrayTypes","_listeners","_interfaces","_instances","_bindings","_arrayMembers","ARRAY_MEMBERS","_arrayMutators","ARRAY_MUTATORS","T","_instanceId","_interfaceId","Exception","ExtendableBuiltin","cls","apply","arguments","prototype","create","setPrototypeOf","AxialUnsupportedType","message","AxialInvalidType","given","expected","key","AxialInvalidNumericRange","AxialInvalidStringPattern","AxialUndefinedValue","source","path","AxialTypeAlreadyDefined","typeName","schema","AxialInvalidArgument","index","AxialMissingProperty","AxialIllegalProperty","_name","Errors","UnsupportedType","InvalidNumericRange","UndefinedValue","InvalidArgument","MissingProperty","IllegalProperty","AxialType","_defaultValue","_baseType","_validator","copy","hasOwnProperty","baseType","options","clone","AxialTypePrototype","AxialNull","AxialUndefined","AxialString","_pattern","call","match","AxialNumber","_min","MIN_SAFE_INTEGER","_max","MAX_SAFE_INTEGER","AxialBoolean","AxialDate","AxialRegex","RegExp","AxialFunction","AxialArray","_type","isArray","l","i","item","t","validate","AxialObject","isPlainObject","AxialInterface","interfaceName","rootInterface","_properties","Map","_allProps","_rootInterface","_methods","expandDotSyntaxKeys","object","setObjectAtPath","definedTypes","typeDef","isTypePlainObject","typeArray","isType","property","AxialInterfaceProperty","getType","defaultValues","parentInstance","AxialInstance","AxialInstanceProxy","get","subPath","split","slice","join","obj","primaryInterface","forEach","expectedType","givenType","defineAccessors","AxialInstanceArray","entries","k","indexOf","keys","_iparent","isRootInterface","_instance","_state","_iface","_parentInstance","_isWatching","_super","ifaceToIndex","methods","defineProperty","listeners","dispose","shouldThrowIfNotFound","getObjectAtPath","bool","clearInterval","_watchIntervalId","props","setInterval","_key","_path","pType","hasValidated","errors","rawValue","_array","error","map","oldValue","console","log","stringify","_isAxialBound","args","JSON","newValue","primaryType","find","AxialBinding","handler","_property","_handler","_active","member","enumerable","isMutator","isItem","returnValue","argsToItems","o","getPrototypeOf","merge","target","_source","_target","sourceValue","targetValue","getObjectPaths","includeBranchPaths","ref","walk","p","getObjectPathValues","keyValues","isBranch","steps","multiSetObjectAtPath","pathOrObject","modifiedPaths","resolver","typeId","orUndefined","orUndefinedOrNull","Type","getInterface","ifaceArray","interfaceNames","filter","interfaces","instances","bindings","bindingInfo","binding","Binding","window","ARRAY_MUTATORS_REQUIRE_ARGS_VALIDATED"],"mappings":"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AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,QAAO;;AAEP;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA,yFAAwF,aAAa;AACrG;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,QAAO;;AAEP;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA,6FAA4F,eAAe;AAC3G;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA,iFAAgF,eAAe;AAC/F;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,QAAO;;AAEP;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uEAAsE,eAAe;AACrF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,EAAC,+BAA+B;;AAEhC;AACA;;AAEA;;AAEA;;AAEA;AACA,EAAC,4BAA4B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC,8B;;;;;;ACzZD;;AAEA;;;;;;;ACFA;;AAEA;;;;;;;ACFA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;;AAEA,+EAA8E,qCAAqC,EAAE;;AAErH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AC/CA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;AACL;;AAEA,MAAK;AACL;;AAEA,MAAK;AACL;;AAEA,MAAK;AACL;AACA;;AAEA,IAAG;AACH;AACA;;AAEA,IAAG;AACH;AACA;;AAEA,IAAG;AACH;AACA;;AAEA,IAAG;AACH;AACA;;AAEA,IAAG;AACH;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA,IAAG;AACH;AACA;;AAEA,IAAG;AACH;AACA;;AAEA,IAAG;AACH;AACA;;AAEA,IAAG;AACH;AACA;;AAEA,IAAG;AACH;AACA;;AAEA,IAAG;AACH;AACA;;AAEA,IAAG;AACH;AACA;;AAEA,IAAG;AACH;AACA;;AAEA,IAAG;AACH;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;;AAEA,sBAAqB,gBAAgB;;AAErC;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;;AAEA;AACA,kCAAiC,QAAQ;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACzJA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA2B;AAC3B;AACA;AACA;AACA,6BAA4B,UAAU;;;;;;;ACnLtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,mDAAmD;AACxE;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,wCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;AACA,cAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAgD,EAAE;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAwB,eAAe;AACvC;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,yBAAwB,QAAQ;AAChC;AACA,sBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,oBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAuD,OAAO;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAuD,OAAO;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAqB,QAAQ;AAC7B;AACA;AACA,IAAG;AACH;AACA,gBAAe,SAAS;AACxB;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,gBAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC5vDA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,qBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA0C,UAAU;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAQ,WAAW;;AAEnB;AACA;AACA;AACA,SAAQ,WAAW;;AAEnB;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA,SAAQ,WAAW;;AAEnB;AACA;AACA,SAAQ,UAAU;;AAElB;AACA;;;;;;;ACnFA,kBAAiB;;AAEjB;AACA;AACA;;;;;;;ACJA;;AAEA;AACA;AACA,EAAC;;AAED;;AAEA;;AAEA,uCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA,0FAAyF,aAAa;AACtG;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,0B;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,yCAAyC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,kDAAiD,yBAAyB;AAC1E;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,kDAAiD,yBAAyB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC;AACvC,kBAAiB,wBAAwB;AACzC;AACA;AACA;;AAEA;AACA,2CAA0C;AAC1C;;AAEA,yBAAwB;AACxB,wBAAuB;AACvB,0BAAyB;AACzB,yBAAwB;AACxB,0BAAyB;AACzB,0BAAyB;AACzB,0BAAyB;AACzB,2BAA0B;;AAE1B,iEAAgE,oBAAoB;AACpF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAkC,OAAO;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,4CAA4C;AAC7D;AACA;AACA;AACA;;;;;;;AC9MA;;AAEA;AACA;AACA,EAAC;AACD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAsC,uCAAuC,gBAAgB;;AAE7F,mCAAkC,0BAA0B,0CAA0C,gBAAgB,OAAO,kBAAkB,EAAE,aAAa,EAAE,OAAO,wBAAwB,EAAE,EAAE;;;AAGnM;;AAEA,2HAA0H;;AAE1H;AACA;AACA;;AAEA;;AAEA;AACA,iCAAgC,QAAQ;AACxC;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA,sDAAqD,2EAA2E;AAChI,IAAG;AACH;AACA;AACA;AACA,MAAK,kBAAkB,gDAAgD;AACvE;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,+FAA8F;;AAE9F;AACA;AACA,MAAK;AACL;;AAEA;AACA,G;;;;;;ACxHA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAmC,gCAAgC;AACnE;AACA,6BAA4B,cAAc;AAC1C;AACA;AACA,GAAE,YAAY;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;;AAEA;;AAEA;;;;;;;ACvDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC,iBAAiB;AAC1D,uDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,mBAAmB;AACpC;AACA;AACA;;AAEA;AACA,kBAAiB,mBAAmB;AACpC;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;;AAEA;;;;;;;AC3IA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,OAAO;AAC9B;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpBA;;AAEA;AACA;AACA,EAAC;AACD;;AAEA,qGAAoG,mBAAmB,EAAE,mBAAmB,kGAAkG;;AAE9O;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,uCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,G;;;;;;ACjJA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAiC,cAAc;AAC/C;AACA;;;;;;;AClBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC,kBAAiB;AACjB;AACA,mCAAkC;AAClC,sCAAqC;AACrC;AACA,iEAAgE;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iEAAgE,OAAO;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,GAAE;AACF;AACA;AACA;AACA,KAAI;AACJ,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAuB,WAAW;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,yCAAyC,qBAAqB;AACjF,sBAAqB,0CAA0C,oBAAoB;AACnF;AACA;AACA,qCAAoC,WAAW;AAC/C;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,wCAAwC,qBAAqB;AAClF,wBAAuB,yCAAyC,oBAAoB;AACpF;AACA;AACA,6BAA4B,WAAW;AACvC;AACA;AACA;AACA,kCAAiC;AACjC,IAAG;AACH,mCAAkC;AAClC,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,mCAAmC,eAAe;AACvE,wBAAuB,kCAAkC,gBAAgB;AACzE;AACA;AACA,gCAA+B,WAAW;AAC1C;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,gDAAgD;AACnE,sBAAqB,gDAAgD;AACrE;AACA;AACA,+BAA8B,WAAW;AACzC;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,kDAAkD;AACtE,uBAAsB,kDAAkD;AACxE;AACA;AACA,6CAA4C,WAAW;AACvD;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,oDAAoD;AACxE,uBAAsB,oDAAoD;AAC1E;AACA;AACA;AACA,yCAAwC,oCAAoC;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,iDAAiD,iBAAiB;AACzG,wCAAuC,gDAAgD,kBAAkB;AACzG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,kCAAkC,gBAAgB;AACrE,qCAAoC;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,uCAAuC,gBAAgB;AAC1E,0CAAyC;AACzC;;AAEA;AACA;AACA;AACA,sBAAqB,6CAA6C,gBAAgB;AAClF,gDAA+C;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAA+C,WAAW;;AAE1D;AACA,gDAA+C,MAAM,6BAA6B,MAAM;AACxF;AACA;AACA;;AAEA;AACA,uCAAsC,sFAAsF;AAC5H,oCAAmC,4DAA4D;AAC/F,oCAAmC,4DAA4D;AAC/F,yDAAwD,mDAAmD;;AAE3G;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,oCAAoC,gBAAgB;AAC9E,yCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,6CAA4C,0DAA0D;AACtG,6CAA4C,0DAA0D;AACtG;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,sDAAqD,iEAAiE;AACtH,sDAAqD,iEAAiE;AACtH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA2B,8CAA8C,kBAAkB;AAC3F;AACA;AACA;AACA,gCAA+B,sEAAsE,kBAAkB;AACvH,4EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAkD;AAClD;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACrSA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;;;;;;;ACdA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAoE,EAAE;AACtE;AACA,GAAE;AACF,gBAAe;AACf;AACA;;AAEA;AACA;AACA,6BAA4B,cAAc;AAC1C;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc,cAAc;AAC5B,iEAAgE,cAAc;AAC9E,uBAAsB,iCAAiC;AACvD,4BAA2B,cAAc;AACzC;AACA;AACA;;;;;;;ACtCA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAkC,aAAa;AAC/C,kCAAiC,cAAc;AAC/C;AACA;;;;;;;ACpBA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oDAAmD,cAAc;AACjE;AACA;;;;;;;ACnBA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA,yCAAwC;AACxC,GAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/BA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAiC,aAAa;AAC9C,kCAAiC,cAAc;AAC/C;AACA;;;;;;;ACnBA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAiC,aAAa;AAC9C,kCAAiC,cAAc;AAC/C;AACA;;;;;;;ACnBA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA4C,cAAc;AAC1D;AACA;AACA;AACA,mCAAkC,aAAa;AAC/C,iDAAgD,cAAc;AAC9D;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;;;;;;;AC1BA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;;;;;;AChBA;;AAEA;AACA;AACA,mCAAkC,aAAa;AAC/C;AACA,iCAAgC,gBAAgB;AAChD,IAAG;AACH;AACA;AACA;AACA,GAAE;;AAEF;AACA,mCAAkC,aAAa;AAC/C;AACA,iCAAgC,gBAAgB;AAChD,IAAG;AACH;AACA;AACA;AACA,GAAE;;AAEF,UAAS;AACT;;;;;;;ACxBA;;AAEA;AACA;AACA,EAAC;;AAED;;AAEA;;AAEA,uCAAsC,uCAAuC,gBAAgB;;AAE7F;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0B","file":"test.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap cca1404dc6ae3780792f","const Axial = require('../lib/axial');\nconst util = Axial.util;\nconst expect = require('expect');\nconst PROXY = Axial.PROXY_KEY;\n\ndescribe('1. Types', () => {\n  it('1.1 should determine correct types', () => {\n    // return as type instances\n    expect(util.typeOf(null)).toBe(Axial.Null);\n    expect(util.typeOf(undefined)).toBe(Axial.Undefined);\n    expect(util.typeOf('abc')).toBe(Axial.String);\n    expect(util.typeOf(123)).toBe(Axial.Number);\n    expect(util.typeOf(true)).toBe(Axial.Boolean);\n    expect(util.typeOf(false)).toBe(Axial.Boolean);\n    expect(util.typeOf(new Date)).toBe(Axial.Date);\n    expect(util.typeOf(/abc/)).toBe(Axial.Regex);\n    expect(util.typeOf(function () {})).toBe(Axial.Function);\n    expect(util.typeOf([])).toBe(Axial.Array());\n    expect(util.typeOf(['abc'])).toBe(Axial.Array(Axial.String));\n    expect(util.typeOf([123])).toBe(Axial.Array(Axial.Number));\n    expect(util.typeOf({})).toBe(Axial.Object);\n    // check name of type\n    expect(util.typeOf(null).name).toBe('null');\n    expect(util.typeOf(undefined).name).toBe('undefined');\n    expect(util.typeOf('abc').name).toBe('string');\n    expect(util.typeOf(123).name).toBe('number');\n    expect(util.typeOf(true).name).toBe('boolean');\n    expect(util.typeOf(false).name).toBe('boolean');\n    expect(util.typeOf(new Date).name).toBe('date');\n    expect(util.typeOf(/abc/).name).toBe('regex');\n    expect(util.typeOf(function () {}).name).toBe('function');\n    expect(util.typeOf([]).name).toBe('array[*]');\n    expect(util.typeOf([]).type).toBe(undefined);\n    expect(util.typeOf(['abc']).name).toBe('array[string]');\n    expect(util.typeOf(['abc']).type.name).toBe('string');\n    expect(util.typeOf([1,2,3]).name).toBe('array[number]');\n    expect(util.typeOf([1,2,3]).type.name).toBe('number');\n    expect(util.typeOf({}).name).toBe('object');\n  });\n});\n\ndescribe('2. Defining Interfaces', () => {\n  let iface = null;\n  let a = null;\n\n  it('2.1 should be able to define an interface without a name', () => {\n    iface = Axial.define({\n      x: {\n        y: {\n          z: [Axial.Number, Axial.Boolean]\n        }\n      },\n      'a.b.c': Axial.Boolean\n    });\n    expect(iface).toBeA(Axial.Interface.constructor);\n    expect(iface.prop('a.b.c').is(Axial.Boolean)).toBe(true);\n  });\n\n  it('2.2 should be able to define an interface with a name', () => {\n    iface = Axial.define('iface', {\n      'x.y.z': [Axial.Number, Axial.Boolean],\n      v: Axial.Array(),\n      w: Axial.Array(Axial.String)\n    });\n    expect(iface.prop('iface.x.y.z').iface.name).toBe('iface.x.y');\n  });\n\n  it('2.3 should be able to access interface properties by path', () => {\n    expect(iface.prop('iface.x').is(Axial.Interface)).toBe(true);\n    expect(iface.prop('iface.x').is(Axial.String)).toBe(false);\n    expect(iface.prop('iface.x.y.z').is(Axial.Number)).toBe(true);\n    expect(iface.prop('iface.x.y.z').is(Axial.Boolean)).toBe(true);\n    expect(iface.prop('iface.v').is(Axial.Array())).toBe(true);\n    expect(iface.prop('iface.v').is(Axial.Array(Axial.String))).toBe(false);\n    expect(iface.prop('iface.w').is(Axial.Array(Axial.String))).toBe(true);\n    expect(iface.prop('iface.w').is(Axial.Array(Axial.Number))).toBe(false);\n  });\n\n  it('2.4 should not be able to define the same type more than once', () => {\n    expect(() => {\n      Axial.define({\n        x: [Axial.String, Axial.Number, Axial.String]\n      });\n    }).toThrow(Axial.TypeAlreadyDefined);\n    expect(() => {\n      Axial.define({\n        x: [Axial.Array(), Axial.Number, Axial.Array()]\n      });\n    }).toThrow(Axial.TypeAlreadyDefined);\n    expect(() => {\n      Axial.define({\n        x: [Axial.Array(Axial.String), Axial.Array(Axial.Number), Axial.Array(Axial.String)]\n      });\n    }).toThrow(Axial.TypeAlreadyDefined);\n  });\n});\n\ndescribe('3. Creating Instances', () => {\n  let iface = Axial.define('iface', {\n    x: {\n      y: {\n        z: [Axial.Number, Axial.Boolean, Axial.Undefined]\n      }\n    },\n    a: {\n      b: Axial.Function\n    }\n  });\n\n  let a = null;\n\n  it('3.1.a should be able to create instances of interfaces', function () {\n    a = iface.new();\n    expect(a).toBeA(Axial.Instance.constructor);\n  });\n\n  it('3.1.b should be able to create instances of interfaces with given values', () => {\n    iface = Axial.define('iface', {\n      x: {\n        y: {\n          z: [Axial.Number, Axial.Boolean, Axial.Undefined]\n        }\n      },\n      a: {\n        b: Axial.Function.orNull()\n      }\n    });\n\n    a = iface.new({\n      'x.y.z': 6,\n      a: {\n        b: function () {\n          return this[PROXY].root.x.y.z;\n        }\n      }\n    });\n    expect(a.x).toBeA(Axial.Instance.constructor);\n    expect(a.x.y).toBeA(Axial.Instance.constructor);\n    expect(a.x.y.z).toBe(6);\n    expect(a.a.b()).toBe(6);\n  });\n\n  it('3.2.a should NOT be allowed to create instance with non-interface properties', () => {\n    expect(() => {\n      iface.new({\n        a: 1\n      });\n    }).toThrow(Axial.UnknownInterfaceKey);\n  });\n\n  it('3.2.b should NOT be allowed to create instance with invalid type', () => {\n    expect(() => {\n      iface.new({\n        x: {\n          y: false\n        }\n      });\n    }).toThrow(Axial.InvalidType);\n    expect(() => {\n      iface.new({\n        x: {\n          y: {\n            z: 'foo'\n          }\n        }\n      });\n    }).toThrow(Axial.InvalidType);\n    expect(() => {\n      iface.new({\n        x: {\n          y: {}\n        }\n      });\n    }).toThrow(Axial.InvalidType);\n  });\n\n  it('3.3 should be able to set multiple types', () => {\n    expect(() => {\n      a.x.y.z = 5;\n      a.x.y.z = false;\n    }).toNotThrow();\n    expect(() => {\n      a.x.y.z = {};\n    }).toThrow(Axial.InvalidType);\n  });\n\n  it('3.4 should be able to use arrays', () => {\n    iface = Axial.define('iface', {\n      a: Axial.Array(),\n      b: Axial.Array(Axial.String),\n      c: Axial.Array(Axial.Object),\n      d: Axial.Array(Axial.Array(Axial.String))\n    });\n    a = iface.new();\n    a.a = [];\n    a.b = [];\n    a.b = ['abc'];\n    a.c = [];\n    a.c = [{x:1}];\n    a.d = [];\n    a.d = [['abc'], ['efg']];\n    expect(() => a.a = false).toThrow(Axial.InvalidType);\n    expect(() => a.b = [123]).toThrow(Axial.InvalidType);\n    expect(() => a.c = [[]]).toThrow(Axial.InvalidType);\n    expect(() => a.c = [[123]]).toThrow(Axial.InvalidType);\n  });\n\n  it('3.5 should be able to use objects', () => {\n    iface = Axial.define('iface', {\n      a: Axial.Object\n    });\n    a = iface.new();\n    a.a = {x:1};\n    expect(() => a.a = false).toThrow(Axial.InvalidType);\n    expect(() => a.a = [123]).toThrow(Axial.InvalidType);\n  });\n});\n\ndescribe('4. Configuring Interface Property Types', () => {\n  let iface;\n\n  it('4.1 should be able to set default property', () => {\n    iface = Axial.define({\n      x: Axial.Number.extend({\n        defaultValue: 5,\n        min: -10,\n        max: 10\n      }),\n      y: Axial.String.extend({\n        defaultValue: 'foo',\n        pattern: /foo/\n      }),\n      a: Axial.String.extend({\n        defaultValue: 'baz',\n        validator: value => {\n          if (value !== 'baz') {\n            throw new Error('Not a baz!');\n          }\n        }\n      }),\n      b: Axial.Number.extend({\n        validator: value => {\n          if (value % 10 !== 0) {\n            throw new Error('Must be multiple of 10');\n          }\n        }\n      })\n    });\n    expect(iface.new().x).toBe(5);\n  });\n\n  it('4.2 should be able to set min/max values for numbers', () => {\n    expect(() => {\n      iface.new({x:-11});\n    }).toThrow(Axial.InvalidNumericType);\n    expect(() => {\n      iface.new({x:11});\n    }).toThrow(Axial.InvalidNumericType);\n  });\n\n  it('4.3 should be able to match a string with a regex pattern', () => {\n    expect(() => {\n      iface.new({y:'bah'});\n    }).toThrow(Axial.InvalidStringPattern);\n    expect(() => {\n      iface.new({y:'foo'});\n    }).toNotThrow();\n  });\n\n  it('4.4 should be able to supply custom validator function', () => {\n    expect(() => {\n      iface.new({a:'bah'});\n    }).toThrow();\n    expect(() => {\n      iface.new({a:'baz'});\n    }).toNotThrow();\n    expect(() => {\n      iface.new({b:1000});\n    }).toNotThrow();\n    expect(() => {\n      iface.new({b:12});\n    }).toThrow();\n  });\n});\n\ndescribe('5. Listening to instance changes', () => {\n  let iface = Axial.define('iface', {\n    a: Axial.Object\n  });\n  let a = iface.new();\n\n  it('5.1 should be able to listen to set property changes of instances (global/local)', () => {\n    let handlerCount = 0;\n    const fn = eventData => {\n      expect(eventData.method).toBe('set');\n      expect(eventData.value.y).toBe(5);\n      handlerCount++;\n    };\n    Axial.bind(fn);\n    a[PROXY].bind('a', fn);\n    a.a = {y:5};\n    a[PROXY].unbind();\n    Axial.unbind();\n    expect(handlerCount).toBe(2);\n  });\n\n  it('5.2 should be able to listen to get property changes of instances (global/local)', () => {\n    let handlerCount = 0;\n    const fn = eventData => {\n      expect(eventData.method).toBe('get');\n      expect(eventData.value.y).toBe(5);\n      handlerCount++;\n    };\n    Axial.bind(fn);\n    a[PROXY].bind('a', fn);\n    const test = a.a;\n    a[PROXY].unbind();\n    Axial.unbind();\n    expect(handlerCount).toBe(2);\n  });\n});\n\ndescribe('6. Composite interfaces', () => {\n  it('6.1 should be able to compose interfaces from other interfaces', () => {\n    let ifaceA = Axial.define('ifaceA', {\n      x: [Axial.String, Axial.Undefined],\n      y: {\n        z: [Axial.Number, Axial.Undefined]\n      }\n    });\n    let ifaceB = Axial.define('ifaceB', {\n      a: ifaceA,\n      b: {\n        c: [Axial.Number, ifaceA]\n      }\n    });\n    let a = ifaceB.new();\n    expect(() => {\n      ifaceB.new({\n        a: {\n          x: 'a',\n          y: {\n            z: 3\n          }\n        },\n        b: {\n          c: 2\n        }\n      });\n    }).toNotThrow();\n    expect(() => {\n      ifaceB.new({\n        a: {\n          x: 'a',\n          y: {\n            z: 'abc' // <- error\n          }\n        },\n        b: {\n          c: 2\n        }\n      });\n    }).toThrow();\n    expect(() => {\n      ifaceB.new({\n        a: {\n          x: 'a',\n          y: {\n            z: 3\n          }\n        },\n        b: {\n          c: {\n            x: 'a',\n            y: {\n              z: 3\n            }\n          }\n        }\n      })\n    }).toNotThrow();\n    expect(() => {\n      ifaceB.new({\n        a: {\n          x: 'a',\n          y: {\n            z: 3\n          }\n        },\n        b: {\n          c: {\n            x: 'a',\n            y: {\n              z: 3\n            }\n          }\n        }\n      })\n    }).toNotThrow();\n    expect(() => {\n      ifaceB.new({\n        a: {\n          x: 'a',\n          y: {\n            z: 3\n          }\n        },\n        b: {\n          c: {\n            x: 'a',\n            y: {\n              z: 'a' // <- error\n            }\n          }\n        }\n      })\n    }).toThrow();\n  });\n});\n\ndescribe('7. Arrays', () => {\n  it('7.1 should be able to bind array mutations to instance values', () => {\n    const IFace = Axial.define({\n      a: Axial.Array(Axial.Number)\n    });\n    const instance = IFace.new({\n      a: [1, 2, 3]\n    });\n    const array = instance.a;\n    const proxy = instance[PROXY];\n    let dispatch = 0;\n\n    // copyWithin\n    proxy.bind('a', e => {\n      expect(e.arrayMethod).toBe('copyWithin');\n      expect(array.length).toBe(3);\n      expect(array.array).toEqual([1,1,2]);\n      dispatch++;\n    });\n    array.copyWithin(1, 0);\n    proxy.unbind('a');\n\n    // fill\n    proxy.bind('a', e => {\n      expect(e.arrayMethod).toBe('fill');\n      expect(array.length).toBe(3);\n      expect(array.array).toEqual([4,4,4]);\n      dispatch++;\n    });\n    array.fill(4);\n    proxy.unbind('a');\n\n    // pop\n    proxy.bind('a', e => {\n      expect(e.arrayMethod).toBe('pop');\n      expect(array.length).toBe(2);\n      expect(array.array).toEqual([4,4]);\n      dispatch++;\n    });\n    array.pop();\n    proxy.unbind('a');\n\n    // push\n    proxy.bind('a', e => {\n      expect(e.arrayMethod).toBe('push');\n      expect(array.length).toBe(3);\n      expect(array.array).toEqual([4,4,5]);\n      dispatch++;\n    });\n    array.push(5);\n    proxy.unbind('a');\n\n    // reverse\n    proxy.bind('a', e => {\n      expect(e.arrayMethod).toBe('reverse');\n      expect(array.length).toBe(3);\n      expect(array.array).toEqual([5,4,4]);\n      dispatch++;\n    });\n    array.reverse();\n    proxy.unbind('a');\n\n    // shift\n    proxy.bind('a', e => {\n      expect(e.arrayMethod).toBe('shift');\n      expect(array.length).toBe(2);\n      expect(array.array).toEqual([4,4]);\n      dispatch++;\n    });\n    expect(array.shift()).toBe(5);\n    proxy.unbind('a');\n\n    // sort\n    array.push(3);\n    proxy.bind('a', e => {\n      expect(e.arrayMethod).toBe('sort');\n      expect(array.length).toBe(3);\n      expect(array.array).toEqual([3,4,4]);\n      dispatch++;\n    });\n    array.sort((a, b) => {\n      return a < b ? -1 : a > b ? 1 : 0;\n    });\n    proxy.unbind('a');\n\n    // splice\n    let round = 1;\n    proxy.bind('a', e => {\n      expect(e.arrayMethod).toBe('splice');\n      if (round === 1) {\n        expect(array.length).toBe(2);\n        expect(array.array).toEqual([3,4]);\n      } else if (round === 2) {\n        expect(array.length).toBe(5);\n        expect(array.array).toEqual([1,2,3,3,4]);\n      } else {\n        throw new Error('Too many rounds!');\n      }\n      round++;\n      dispatch++;\n    });\n    array.splice(1, 1);\n    array.splice(0, 0, 1,2,3);\n    proxy.unbind('a');\n\n    // unshift\n    proxy.bind('a', e => {\n      expect(e.arrayMethod).toBe('unshift');\n      expect(array.length).toBe(7);\n      expect(array.array).toEqual([7,8,1,2,3,3,4]);\n      dispatch++;\n    });\n    expect(array.unshift(7,8)).toBe(7);\n    proxy.unbind('a');\n\n    expect(dispatch).toBe(10);\n  });\n\n  it('7.2 should not be able to add illegal type to typed array', () => {\n    const Item = Axial.define({text: Axial.String});\n    const List = Axial.define({items: Axial.Array(Item)});\n    const list = List.new();\n    const validItem = Item.new();\n    const invalidItem = {foo:'bar'};\n    list.items.add(validItem);\n    expect(() => {\n      list.items.add(invalidItem);\n    }).toThrow();\n    expect(list.items.contains(validItem)).toBe(true);\n    expect(list.items.contains(invalidItem)).toBe(false);\n    list.items.remove(validItem);\n    expect(list.items.isEmpty).toBe(true);\n    expect(list.items.contains(validItem)).toBe(false);\n  });\n});\n\ndescribe('8. Interface Inheritance', () => {\n  let ifaceA, ifaceB, ifaceC;\n  let inst;\n\n  it('8.1 should be able to define interfaces which inherit from another interface', () => {\n    ifaceA = Axial.define('ifaceA', {\n      a: Axial.String.set('a'),\n      foo: Axial.String,\n      who: Axial.Function.set(x => {\n        return 'ifaceA-' + x;\n      })\n    });\n\n    ifaceB = ifaceA.extend('ifaceB', {\n      b: Axial.String.set('b'),\n      foo: Axial.Number,\n      who: Axial.Function.set(x => {\n        return 'ifaceB-' + x;\n      })\n    });\n\n    ifaceC = ifaceB.extend('ifaceC', {\n      c: Axial.String.set('c'),\n      foo: Axial.Boolean,\n      who: Axial.Function.set(x => {\n        return 'ifaceC-' + x;\n      })\n    });\n  });\n\n  it('8.2.a interface should be able to inherit from another interface by one level', () => {\n    inst = ifaceB.new();\n    expect(() => {\n      inst.foo = 'string'; // invalid input\n    }).toThrow();\n    expect(() => {\n      inst.foo = 3; // valid input\n    }).toNotThrow();\n    expect(ifaceB.has('a')).toBe(true);\n    expect(ifaceB.has('b')).toBe(true);\n    expect(ifaceB.has('foo')).toBe(true);\n    expect(ifaceB.has('who')).toBe(true);\n    expect(ifaceB.prop('a').iface.name).toBe('ifaceA');\n    expect(ifaceB.prop('b').iface.name).toBe('ifaceB');\n    expect(ifaceB.prop('foo').iface.name).toBe('ifaceB');\n    expect(ifaceB.prop('who').iface.name).toBe('ifaceB');\n    expect(inst.who(123)).toBe('ifaceB-123');\n    expect(inst[PROXY].super.ifaceA.who(123)).toBe('ifaceA-123');\n  });\n\n  it('8.2.b interface should be able to to inherit from another interface by multiple levels', () => {\n    inst = ifaceC.new();\n    expect(() => {\n      inst.foo = 3; // invalid input\n    }).toThrow();\n    expect(() => {\n      inst.foo = false; // valid input\n    }).toNotThrow();\n    expect(ifaceC.has('a')).toBe(true);\n    expect(ifaceC.has('b')).toBe(true);\n    expect(ifaceC.has('c')).toBe(true);\n    expect(ifaceC.has('foo')).toBe(true);\n    expect(ifaceC.has('who')).toBe(true);\n    expect(ifaceC.prop('a').iface.name).toBe('ifaceA');\n    expect(ifaceC.prop('b').iface.name).toBe('ifaceB');\n    expect(ifaceC.prop('c').iface.name).toBe('ifaceC');\n    expect(ifaceC.prop('foo').iface.name).toBe('ifaceC');\n    expect(ifaceC.prop('who').iface.name).toBe('ifaceC');\n    expect(inst.who(123)).toBe('ifaceC-123');\n    expect(inst[PROXY].super.ifaceA.who(123)).toBe('ifaceA-123');\n    expect(inst[PROXY].super.ifaceB.who(123)).toBe('ifaceB-123');\n  });\n});\n\n\n// WEBPACK FOOTER //\n// ./test/test.js","module.exports = (function Define_Axial () {\n  const CONST = require('./const');\n  const PROXY_KEY = CONST.PROXY_KEY;\n  const BLANK_INTERFACE_NAME = CONST.BLANK_INTERFACE_NAME;\n  const _arrayTypes = {};\n  const _listeners = [];\n  const _interfaces = {};\n  const _instances = {};\n  const _bindings = [];\n  const _arrayMembers = CONST.ARRAY_MEMBERS;\n  const _arrayMutators = CONST.ARRAY_MUTATORS;\n\n  let util, T;\n  let _instanceId = 0, _interfaceId = 0;\n\n  // -------------------------------------------------------------------------------------- Errors\n  const Exception = (function ExtendableBuiltin(cls){\n    function ExtendableBuiltin(){\n      cls.apply(this, arguments);\n    }\n    ExtendableBuiltin.prototype = Object.create(cls.prototype);\n    Object.setPrototypeOf(ExtendableBuiltin, cls);\n    return ExtendableBuiltin;\n  })(Error);\n\n  class AxialUnsupportedType extends Exception {\n    constructor (value) {\n      const message = `Unsupported type \"${'' + typeof value}\". Only AxialTypes can be provided.`;\n      super(message);\n      this.value = value;\n      this.message = message;\n    }\n  }\n\n  class AxialInvalidType extends Exception {\n    constructor (given, expected, key, iface) {\n      const message = `Invalid type${key ? ' for property \"' + key +'\"' : ''} - \"${given}\" given, \"${expected}\" expected`;\n      super(message);\n      this.given = given;\n      this.expected = expected;\n      this.key = key;\n      this.iface = iface;\n      this.message = message;\n    }\n  }\n\n  class AxialInvalidNumericRange extends Exception {\n    constructor (given, min, max) {\n      const message = `Invalid numeric range - expected [${min} .. ${max}], given ${given}`;\n      super(message);\n      this.given = given;\n      this.min = min;\n      this.max = max;\n      this.message = message;\n    }\n  }\n\n  class AxialInvalidStringPattern extends Exception {\n    constructor (given, pattern) {\n      const message = `Invalid string pattern - expected \"${pattern}\", given \"${given}\"`;\n      super(message);\n      this.given = given;\n      this.pattern = pattern;\n      this.message = message;\n    }\n  }\n\n  class AxialUndefinedValue extends Exception {\n    constructor (source, path) {\n      const message = `Undefined value for object path \"${path}\"`;\n      super(message);\n      this.source = source;\n      this.path = path;\n      this.message = message;\n    }\n  }\n\n  class AxialTypeAlreadyDefined extends Exception {\n    constructor (typeName, key, schema) {\n      const message = `Type \"${typeName}\" is already defined for property \"${key}\" in schema \"${schema.name}\"`;\n      super(message);\n      this.typeName = typeName;\n      this.key = key;\n      this.schema = schema;\n      this.message = message;\n    }\n  }\n\n  class AxialInvalidArgument extends Exception {\n    constructor (index, expected, given) {\n      const message = `Invalid argument #${index} - Expected \"${expected}\", given \"${given}\"`;\n      super(message);\n      this.index = index;\n      this.expected = expected;\n      this.given = given;\n    }\n  }\n\n  class AxialMissingProperty extends Exception {\n    constructor (key, iface) {\n      const message = `Missing interface ${key} from given object`;\n      super(message);\n      this.key = key;\n      this.iface = iface;\n      this.message = message;\n    }\n  }\n\n  class AxialIllegalProperty extends Exception {\n    constructor (key, iface) {\n      const message = `Illegal key \"${key}\" not declared in interface \"${iface._name}\"`;\n      super(message);\n      this.key = key;\n      this.iface = iface;\n      this.message = message;\n    }\n  }\n\n  const Errors = {\n    UnsupportedType: AxialUnsupportedType,\n    InvalidType: AxialInvalidType,\n    InvalidNumericRange: AxialInvalidNumericRange,\n    InvalidStringPattern: AxialInvalidStringPattern,\n    UndefinedValue: AxialUndefinedValue,\n    TypeAlreadyDefined: AxialTypeAlreadyDefined,\n    InvalidArgument: AxialInvalidArgument,\n    MissingProperty: AxialMissingProperty,\n    IllegalProperty: AxialIllegalProperty\n  };\n\n  // -------------------------------------------------------------------------------------- Types\n  class AxialType {\n    constructor () {\n      this._defaultValue = undefined;\n      this._baseType = this;\n      this._validator = null;\n    }\n\n    static get name () {\n      return '?';\n    }\n\n    get name () {\n      return this._name || this.constructor.name;\n    }\n\n    validate (value) {\n      if (typeof this._validator === 'function') {\n        this._validator(value);\n        return;\n      }\n      if (!this.is(value)) {\n        throw new AxialInvalidType(this.name, util.typeOf(value).name);\n      }\n    }\n\n    is (value) {\n      return typeof value === this.name;\n    }\n\n    toString () {\n      return this.name;\n    }\n\n    clone () {\n      const copy = new this.constructor;\n      for (let key in this) {\n        if (this.hasOwnProperty(key)) {\n          copy[key] = this[key];\n        }\n      }\n      copy._baseType = this.baseType;\n      return copy;\n    }\n\n    extend (options) {\n      const copy = this.clone();\n      for (let key in options) {\n        if (options.hasOwnProperty(key)) {\n          copy['_' + key] = options[key];\n        }\n      }\n      return copy;\n    }\n\n    get baseType () {\n      return this._baseType ? this._baseType : this;\n    }\n\n    defaultValue (value) {\n      const copy = this.clone();\n      copy._defaultValue = value;\n      return copy;\n    }\n  }\n\n  const AxialTypePrototype = AxialType.prototype;\n\n  class AxialNull extends AxialType {\n    constructor () {\n      super();\n      this._defaultValue = null;\n    }\n\n    static get name () {\n      return 'null';\n    }\n\n    is (value) {\n      return value === null;\n    }\n  }\n\n  class AxialUndefined extends AxialType {\n    constructor () {\n      super();\n      this._defaultValue = undefined;\n    }\n\n    static get name () {\n      return 'undefined';\n    }\n\n    is (value) {\n      return typeof value === 'undefined';\n    }\n  }\n\n  class AxialString extends AxialType {\n    constructor () {\n      super();\n      this._pattern = null;\n      this._defaultValue = '';\n    }\n\n    validate (value) {\n      if (typeof this._validator === 'function') {\n        this._validator(value);\n        return;\n      }\n      if (!this.is(value)) {\n        if (typeof value !== 'string') {\n          throw new AxialInvalidType('string', util.typeOf(value).name);\n        }\n        throw new AxialInvalidStringPattern(value, this._pattern);\n      }\n    }\n\n    is (value) {\n      return AxialTypePrototype.is.call(this, value)\n        && (this._pattern ? !!value.match(this._pattern) : true);\n    }\n\n    static get name () {\n      return 'string';\n    }\n  }\n\n  class AxialNumber extends AxialType {\n    constructor () {\n      super();\n      this._min = Number.MIN_SAFE_INTEGER;\n      this._max = Number.MAX_SAFE_INTEGER;\n      this._defaultValue = 0;\n    }\n\n    validate (value) {\n      if (typeof this._validator === 'function') {\n        this._validator(value);\n        return;\n      }\n      if (!this.is(value)) {\n        if (typeof value !== 'number') {\n          throw new AxialInvalidType('number', util.typeOf(value).name);\n        }\n        throw new AxialInvalidNumericRange(value, this._min, this._max);\n      }\n    }\n\n    is (value) {\n      return AxialTypePrototype.is.call(this, value)\n        && (value >= this._min && value <= this._max);\n    }\n\n    static get name () {\n      return 'number';\n    }\n  }\n\n  class AxialBoolean extends AxialType {\n    constructor () {\n      super();\n      this._defaultValue = false;\n    }\n\n    static get name () {\n      return 'boolean';\n    }\n  }\n\n  class AxialDate extends AxialType {\n    constructor () {\n      super();\n      this._defaultValue = new Date();\n    }\n\n    static get name () {\n      return 'date';\n    }\n\n    is (value) {\n      return value instanceof Date;\n    }\n  }\n\n  class AxialRegex extends AxialType {\n    constructor () {\n      super();\n      this._defaultValue = new RegExp('.*', 'i');\n    }\n\n    static get name () {\n      return 'regex';\n    }\n\n    is (value) {\n      return value instanceof RegExp;\n    }\n  }\n\n  class AxialFunction extends AxialType {\n    constructor () {\n      super();\n      this._defaultValue = new Function();\n    }\n\n    static get name () {\n      return 'function';\n    }\n\n    is (value) {\n      return typeof value === 'function';\n    }\n  }\n\n  class AxialArray extends AxialType {\n    constructor (type) {\n      super();\n      this._type = type;\n      this._defaultValue = [];\n    }\n\n    static get name () {\n      return 'array';\n    }\n\n    is (value) {\n      const isArray = Array.isArray(value);\n      if (isArray) {\n        if (this._type instanceof AxialType) {\n          const l = value.length;\n          for (let i = 0; i < l; i++) {\n            if (!this._type.is(value[i])) {\n              return false;\n            }\n          }\n        }\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    isItem (item) {\n      if (this._type) {\n        return util.typeOf(item).name === this._type.name;\n      }\n      return true;\n    }\n\n    validate (value) {\n      if (!Array.isArray(value)) {\n        throw new AxialInvalidType(this.name, util.typeOf(value).name);\n      }\n      if (this._type) {\n        const l = value.length;\n        const t = this._type;\n        for (let i = 0; i < l; i++) {\n          t.validate(value[i]);\n        }\n      }\n    }\n\n    get type () {\n      return this._type;\n    }\n  }\n\n  class AxialObject extends AxialType {\n    constructor () {\n      super();\n      this._defaultValue = {};\n    }\n\n    static get name () {\n      return 'object';\n    }\n\n    is (value) {\n      return util.isPlainObject(value) || (typeof value === 'object' && (value !== null && !Array.isArray(value)));\n    }\n  }\n\n  class AxialInterface extends AxialObject {\n    constructor (interfaceName = BLANK_INTERFACE_NAME, prototype, rootInterface) {\n      super();\n\n      if (util.isPlainObject(interfaceName) && typeof prototype === 'undefined') {\n        // handle case where just single object prototype argument given\n        prototype = interfaceName;\n        interfaceName = BLANK_INTERFACE_NAME;\n      }\n\n      if (interfaceName === BLANK_INTERFACE_NAME) {\n        interfaceName += ++_interfaceId;\n      }\n\n      this._name = interfaceName;\n      this._properties = new Map();\n      this._allProps = new Map();\n      this._rootInterface = rootInterface;\n      this._methods = new Map();\n\n      this.define(prototype);\n\n      if (interfaceName) {\n        Axial.Interface[this._name] = this;\n      }\n\n      const _name = this._name;\n      _interfaces[_name] = _interfaces[_name] ? _interfaces[_name] : [];\n      _interfaces[_name].push(this);\n    }\n\n    define (prototype) {\n      util.expandDotSyntaxKeys(prototype, (path, key, object) => {\n        util.setObjectAtPath(prototype, path, object);\n      });\n\n      for (let key in prototype) {\n        if (prototype.hasOwnProperty(key)) {\n          let definedTypes = {};\n          let typeDef = prototype[key];\n          let isTypePlainObject = util.isPlainObject(typeDef);\n          let typeArray = Array.isArray(typeDef) ? typeDef : [typeDef];\n\n          const path = this._name ? this._name + '.' + key : `${BLANK_INTERFACE_NAME}.` + key;\n\n          if (isTypePlainObject) {\n            typeArray = [new AxialInterface(path, typeDef, this.root)];\n          } else {\n            // check type is only defined once and is AxialType\n            for (let i = 0; i < typeArray.length; i++) {\n              let t = typeArray[i];\n              if (!util.isType(t)) {\n                throw new AxialUnsupportedType(t);\n              }\n              let typeName = t.name;\n              if (definedTypes[typeName]) {\n                throw new AxialTypeAlreadyDefined(t.name, key, this);\n              } else {\n                definedTypes[typeName] = true;\n              }\n            }\n          }\n\n          const property = new AxialInterfaceProperty(this, key, typeArray, path);\n\n          if (property.is(Axial.Function)) {\n            this._methods.set(key, property.getType(Axial.Function)._defaultValue);\n          }\n\n          this._properties.set(key, property);\n        }\n      }\n    }\n\n    create (defaultValues = {}, parentInstance) {\n      // create instance\n      const instance = new AxialInstance();\n      const proxy = new AxialInstanceProxy(instance, this, parentInstance);\n\n      // check undefined keys are not being passed\n      const isPlainObject = util.isPlainObject(defaultValues);\n\n      if (isPlainObject) {\n        util.expandDotSyntaxKeys(defaultValues, (path, key, object) => {\n          if (!this._properties.has(key)) {\n            throw new AxialIllegalProperty(key, this);\n          }\n          const prop = this._properties.get(key);\n          const subPath = path.split('.').slice(1).join('.');\n          const obj = {};\n          util.setObjectAtPath(obj, subPath, object);\n          defaultValues[key] = prop.primaryInterface.create(obj, instance);\n        });\n      }\n\n      for (let key in defaultValues) {\n        if (isPlainObject && defaultValues.hasOwnProperty(key)) {\n          if (!this._properties.has(key)) {\n            throw new AxialIllegalProperty(key, this);\n          }\n        }\n      }\n\n      this._properties.forEach((property, key) => {\n        // install getters and setters for each property in interface\n        let value = defaultValues[key];\n        const expectedType = property.type;\n        const givenType = util.typeOf(value);\n\n        // expect property definition type to be valid AxialType\n        if (defaultValues.hasOwnProperty(key)) {\n          property.validate(value);\n        }\n\n        // define the getter and setter property of the instance\n        instance[PROXY_KEY].defineAccessors(property);\n\n        // if this is an interface, swap with AxialInstance from interface using plain object sub-tree as default values\n        if (property.is(Axial.Interface) && !value) {\n          value = property.primaryInterface.create(value, instance);\n        } else if (!defaultValues.hasOwnProperty(key)) {\n          value = property.defaultValue;\n        }\n\n        // if this is an array, swap with AxialInstanceArray from array value\n        if (Axial.Array.is(value)) {\n          value = new AxialInstanceArray(instance, property, value);\n        }\n\n        // set the value of the property\n        if (typeof value !== 'undefined') {\n          property.set(instance, value);\n        }\n      });\n\n      return instance;\n    }\n\n    validate (value) {\n      // check value is object\n      if (!AxialObject.prototype.is.call(this, value)) {\n        throw new AxialInvalidType(util.typeOf(value).name)\n      }\n\n      // check value has no extra props\n      for (let key in value) {\n        if (value.hasOwnProperty(key)) {\n          if (key !== PROXY_KEY && !this._properties.has(key)) {\n            throw new AxialIllegalProperty(key, this);\n          }\n        }\n      }\n\n      // check each prop validates\n      for (let [k, property] of this._properties.entries()) {\n        if (!value.hasOwnProperty(k)) {\n          throw new AxialMissingProperty(k, this);\n        }\n        property.validate(value[k]);\n      }\n    }\n\n    is (value) {\n      if (!AxialObject.prototype.is.call(this, value)) {\n        return false;\n      }\n\n      // check each prop validates\n      for (let [k, property] of this._properties.entries()) {\n        if (!value.hasOwnProperty(k)) {\n          return false;\n        }\n        try {\n          property.validate(value[k]);\n        } catch (e) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    has (key) {\n      return this._properties.has(key);\n    }\n\n    prop (name) {\n      let path = name;\n      if (this._name && path.indexOf(this._name) !== 0) {\n        path = this._name + '.' + path;\n      }\n      return this.root._allProps.get(path);\n    }\n\n    forEach (fn) {\n      for (let [key, property] of this._properties) {\n        fn(property, key);\n      }\n    }\n\n    keys () {\n      const keys = [];\n      for (let [path, property] of this.root._allProps) {\n        keys.push(path);\n      }\n      return keys;\n    }\n\n    get name () {\n      return this._name;\n    }\n\n    set name (name) {\n      if (this._name) {\n        delete Axial.Interface[this._name];\n        //test-all gone?\n      }\n      this._name = name;\n      Axial.Interface[this._name] = this;\n    }\n\n    get root () {\n      return this._rootInterface ? this._rootInterface : this;\n    }\n\n    get isRootInterface () {\n      return this.root === this;\n    }\n\n    get isSubInterface () {\n      return !this.isRootInterface;\n    }\n\n    extend (interfaceName, prototype = {}) {\n      if (typeof interfaceName !== 'string') {\n        // TODO: make proper error\n        throw new Error('Interface requires name');\n      }\n      const iface = new AxialInterface(interfaceName, prototype);\n      iface._iparent = this;\n      let obj = this;\n      while (obj) {\n        for (let [key, property] of obj._properties.entries()) {\n          if (!iface.has(key)) {\n            iface._properties.set(key, property);\n            iface._allProps.set(interfaceName + '.' + key, property);\n          }\n        }\n        obj = obj._iparent;\n      }\n      return iface;\n    }\n  }\n\n  // -------------------------------------------------------------------------------------- Instances\n  class AxialInstance {\n\n  }\n\n  class AxialInstanceProxy {\n    constructor (instance, iface, parentInstance) {\n      instance[PROXY_KEY] = this;\n      this._instance = instance;\n      this._state = {};\n      this._iface = iface;\n      this._listeners = {};\n      this._parentInstance = parentInstance;\n      this._isWatching = false;\n      this._super = {};\n      this._instanceId = ++_instanceId;\n\n      if (iface) {\n        const _name = iface._name;\n        // track instance\n        // TODO: remove from tracking when dispose?\n        _instances[_name] = _instances[_name] ? _instances[_name] : [];\n        _instances[_name].push(this._instance);\n\n        // go through each AxialInterface._methods and bind copy to this instance\n        let ifaceToIndex = iface;\n        while (ifaceToIndex) {\n          let methods = {};\n          this._super[ifaceToIndex.name] = methods;\n          for (let [key, fn] of ifaceToIndex._methods.entries()) {\n            methods[key] = fn.bind(this._instance);\n          }\n          ifaceToIndex = ifaceToIndex._iparent;\n        }\n      }\n    }\n\n    defineAccessors (property) {\n      const key = property.key;\n      if (this._instance.hasOwnProperty(key)) {\n        // TODO: use real error\n        throw new Error('Illegal property key');\n      }\n      Object.defineProperty(this._instance, key, {\n        // create setter for instance\n        set: function (value) {\n          // wrap property setter\n          return property.set(this._instance, value);\n        }.bind(this),\n        // create getter for instance\n        get: function () {\n          // wrap property getter\n          return property.get(this._instance);\n        }.bind(this)\n      });\n    }\n\n    bind (key, fn) {\n      this._listeners[key] = this._listeners[key] ? this._listeners[key] : [];\n      this._listeners[key].push(fn);\n    }\n\n    prop (path) {\n      return this._iface.prop(path);\n    }\n\n    unbind (key, fn) {\n      if (arguments.length === 0) {\n        this._listeners = {};\n      } else if (key && !fn) {\n        this._listeners[key].length = 0;\n      } else {\n        const index = this._listeners[key].indexOf(fn);\n        this._listeners[key].splice(index, 1);\n      }\n    }\n\n    dispatch (key, eventData) {\n      // dispatch globally too\n      Axial.dispatch(eventData);\n      const listeners = this._listeners[key];\n      if (listeners) {\n        const l = listeners.length;\n        for (let i = 0; i < l; i++) {\n          // dispatch for each event listener to interface keys\n          listeners[i](eventData);\n        }\n      }\n    }\n\n    dispose () {\n      //test-all gone?\n      this._iface.forEach((property, key) => {\n        const item = this._state[key];\n        if (typeof item.dispose === 'function') {\n          item.dispose();\n        }\n        delete this._state[key];\n        delete this._instance[key];\n      });\n      delete this._instance[PROXY_KEY];\n    }\n\n    get root () {\n      let obj = this._parentInstance;\n      let root = this;\n      while (obj) {\n        root = obj;\n        obj = obj._parentInstance;\n      }\n      return root;\n    }\n\n    get super () {\n      return this._super;\n    }\n\n    value (path, shouldThrowIfNotFound) {\n      const root = this.root;\n      return util.getObjectAtPath(root, path, shouldThrowIfNotFound);\n    }\n\n    get debug () {\n      return this._isWatching;\n    }\n\n    set debug (bool) {\n      if (bool && this._isWatching) {\n        return;\n      }\n      if (!bool && this._isWatching) {\n        clearInterval(this._watchIntervalId);\n      }\n      this._isWatching = bool;\n      if (bool) {\n        const props = this._iface._properties;\n        this._watchIntervalId = setInterval(() => {\n          for (let key in this) {\n            if (this.hasOwnProperty(key) && key !== PROXY_KEY && !props.has(key)) {\n              clearInterval(this._watchIntervalId);\n              throw new AxialIllegalProperty(key, this._iface);\n            }\n          }\n        }, 30);\n      }\n    }\n\n    get (key, defaultValue) {\n      const value = this.instance[key];\n      return this._state.hasOwnProperty(key) ? value : defaultValue;\n    }\n\n    set (key, value) {\n      this.instance[key] = value;\n    }\n  }\n\n  class AxialInterfaceProperty {\n    constructor (iface, key, type, path) {\n      this._iface = iface;\n      this._key = key;\n      this._type = type;\n      this._path = path;\n      iface.root._allProps.set(path, this);\n    }\n\n    is (type) {\n      const t = this._type;\n      const l = t.length;\n      for (let i = 0; i < l; i++) {\n        const pType = t[i];\n        if (pType instanceof type.constructor) {\n          if (pType instanceof AxialArray) {\n            if (type._type && pType._type !== type._type) {\n              return false;\n            }\n          }\n          return true;\n        }\n      }\n      return false;\n    }\n\n    validate (value) {\n      const t = this._type;\n      const l = t.length;\n      let hasValidated = false;\n      let errors = [];\n      let rawValue = value;\n      if (value instanceof AxialInstanceArray) {\n        value = value._array;\n      }\n      for (let i = 0; i < l; i++) {\n        let type = t[i];\n        try {\n          type.validate(value);\n          hasValidated = true;\n        } catch (e) {\n          e.key = this.key;\n          errors.push({type:type, error:e});\n        }\n      }\n      if (!hasValidated) {\n        for (let i = 0; i < errors.length; i++) {\n          if (errors[i].type.baseType.is(value)) {\n            throw errors[i].error;\n          }\n        }\n\n        throw new AxialInvalidType(util.typeOf(value).name, t.map(x => x.name).join('|'), this._key, this._iface);\n      }\n    }\n\n    /**\n     * setter\n     * @param instance\n     * @param value\n     */\n    set (instance, value) {\n      const oldValue = instance[PROXY_KEY]._state[this._key];\n      const rawValue = value;\n\n      console.log('%cSET: ' + this._path + ':<' + this._type.join('|') + '> = ' + util.stringify(value), 'color:orange');\n\n      this.validate(value);\n\n      // convert to AxialInstance if Interface and object given\n      if (this.is(Axial.Interface) && util.isPlainObject(value)) {\n        for (let i = 0; i < this._type.length; i++) {\n          if (this._type[i] instanceof AxialInterface) {\n            if (this._type[i].is(value)) {\n              value = this._type[i].create(value, instance);\n              break;\n            }\n          }\n        }\n      }\n\n      // convert to AxialInstanceArray if array\n      if (this.is(Axial.Array()) && Array.isArray(value)) {\n        value = new AxialInstanceArray(instance, this, value);\n      }\n\n      // convert to bound function (if function)\n      if (this.is(Axial.Function) && typeof value === 'function' && !value._isAxialBound) {\n        const fn = value;\n        value = function () {\n          const args = [];\n          const l = arguments.length;\n          for (let i = 0; i < l; i++) {\n            try {\n              args.push(JSON.stringify(arguments[i]));\n            } catch (e) {\n              args.push(util.typeOf(arguments[i]).name);\n            }\n          }\n          console.log('%cCALL: ' + this._key + `(${args.length ? '<' : ''}` + args.join('>, <') + `${args.length ? '>' : ''})`, 'color:pink');\n\n          instance[PROXY_KEY].dispatch(this._key, {\n            instance: instance,\n            property: this,\n            method: 'call',\n            key: this._key,\n            value: arguments,\n            arguments: arguments,\n            newValue: fn,\n            oldValue: fn\n          });\n\n          return fn.apply(instance, arguments);\n        }.bind(this);\n        value._isAxialBound = true;\n      }\n\n      // set state in obj\n      instance[PROXY_KEY]._state[this._key] = value;\n\n      // dispatch event\n      instance[PROXY_KEY].dispatch(this._key, {\n        instance: instance,\n        property: this,\n        method: 'set',\n        key: this._key,\n        value: rawValue,\n        newValue: value,\n        oldValue: oldValue\n      });\n    }\n\n    /**\n     * getter\n     * @param instance\n     * @returns {*}\n     */\n    get (instance) {\n      const value = instance[PROXY_KEY]._state[this._key];\n\n      console.log('%cGET: ' + this._path + ':<' + this._type.join('|') + '> = ' + util.stringify(value), 'color:#999');\n\n      // dispatch event\n      instance[PROXY_KEY].dispatch(this._key, {\n        instance: instance,\n        property: this,\n        method: 'get',\n        key: this._key,\n        value: value\n      });\n\n      return value;\n    }\n\n    getType (type) {\n      for (let i = 0; i < this._type.length; i++) {\n        if (this._type[i].constructor === type.constructor) {\n          return this._type[i];\n        }\n      }\n      // TODO: proper error\n      throw new Error('Type not found');\n    }\n\n    get path () {\n      return this._path;\n    }\n\n    get iface () {\n      return this._iface;\n    }\n\n    get key () {\n      return this._key;\n    }\n\n    get type () {\n      return this._type;\n    }\n\n    get defaultValue () {\n      return this.primaryType._defaultValue;\n    }\n\n    get isSingleType () {\n      return this._type.length === 1;\n    }\n\n    get isInterface () {\n      return this.is(Axial.Interface);\n    }\n\n    get primaryType () {\n      return this._type[0];\n    }\n\n    get primaryInterface () {\n      return this._type.find(type => type instanceof AxialInterface);\n    }\n  }\n\n  class AxialBinding {\n    constructor (instance, key, handler) {\n      this._instance = instance;\n      this._key = key;\n      this._property = instance[PROXY_KEY].prop(this._key);\n      this._handler = handler;\n      this._active = false;\n    }\n\n    bind () {\n      this._instance[PROXY_KEY].bind(this._key, this._handler);\n      this._active = true;\n      _bindings.push(this);\n    }\n\n    unbind () {\n      this._instance[PROXY_KEY].unbind(this._key, this._handler);\n      this._active = false;\n      const i = _bindings.indexOf(this);\n      _bindings.splice(i, 1);\n    }\n\n    dispose () {\n      if (this._active) {\n        this.unbind();\n      }\n      delete this._instance;\n      delete this._handler;\n    }\n\n    get () {\n      return this._instance[PROXY_KEY]._state[this._key];\n    }\n\n    get instance () {\n      return this._instance;\n    }\n\n    get key () {\n      return this._key;\n    }\n\n    get property () {\n      return this._property;\n    }\n\n    get handler () {\n      return this._handler;\n    }\n\n    get isActive () {\n      return this._active;\n    }\n  }\n\n  class AxialInstanceArray {\n    constructor (instance, property, array = []) {\n      this._instance = instance;\n      this._property = property;\n      this._key = property.key;\n      this._array = array;\n\n      _arrayMembers.forEach(member => {\n        // stub each member of Array.prototype\n        // validate arguments if mutator, otherwise validate array afterwards\n        Object.defineProperty(this, member, {\n          enumerable: false,\n          value: function () {\n            const args = Array.prototype.slice.call(arguments);\n            const isMutator = _arrayMutators.indexOf(member) > -1;\n            let hasValidated = true;\n\n            if (member === 'push') {\n              property.validate(args);\n            } else if (member === 'splice') {\n              property.validate(args.slice(2));\n            } else if (member === 'unshift') {\n              property.validate(args);\n            } else if (member === 'fill') {\n              property.primaryType.isItem(args[0]);\n            } else {\n              hasValidated = true;\n            }\n\n            let returnValue = Array.prototype[member].apply(array, args);\n            this.length = array.length;\n\n            if (!hasValidated) {\n              property.validate(array);\n            }\n\n            if (isMutator) {\n              // dispatch event\n              instance[PROXY_KEY].dispatch(this._key, {\n                instance: instance,\n                property: this._property,\n                method: 'set',\n                arrayMethod: member,\n                key: this._key,\n                value: returnValue,\n                newValue: this,\n                oldValue: null\n              });\n            }\n\n            return returnValue;\n          }\n        });\n      });\n    }\n\n    add (/*items, ...*/) {\n      const items = AxialInstanceArray.argsToItems.apply(null, arguments);\n      this.push.apply(this, items);\n    }\n\n    remove (/*items, ...*/) {\n      const array = this._array;\n      const items = AxialInstanceArray.argsToItems.apply(null, arguments);\n      const l = items.length;\n      for (let i = 0; i < l; i++) {\n        const item = items[i];\n        const index = array.indexOf(item);\n        this._array.splice(index, 1);\n      }\n      this.length = this._array.length;\n    }\n\n    contains (/*items, ...*/) {\n      const items = AxialInstanceArray.argsToItems.apply(null, arguments);\n      const l = items.length;\n      const array = this._array;\n      for (let i = 0; i < l; i++) {\n        if (array.indexOf(items[i]) > -1) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    get isEmpty() {\n      return this.length === 0;\n    }\n\n    get instance () {\n      return this._instance;\n    }\n\n    get property () {\n      return this._property;\n    }\n\n    get key () {\n      return this._key;\n    }\n\n    get array () {\n      return this._array;\n    }\n  }\n\n  AxialInstanceArray.argsToItems = function () {\n    const array = [];\n    const l = arguments.length;\n    if (l === 1 && Array.isArray(arguments[0])) {\n      array.push.apply(array, arguments);\n    } else if (l > 0) {\n      for (let i = 0; i < l; i++) {\n        const item = arguments[i];\n        array.push(item);\n      }\n    }\n    return array;\n  };\n\n  // -------------------------------------------------------------------------------------- Util\n  util = {\n    isPlainObject (o) {\n      let t = o;\n      return typeof o !== 'object' || o === null ?\n        false :\n        (function () {\n          while (true) {\n            if (Object.getPrototypeOf(t = Object.getPrototypeOf(t)) === null) {\n              break;\n            }\n          }\n          return Object.getPrototypeOf(o) === t;\n        })();\n    },\n\n    merge (source, target) {\n      let copy = (_source, _target) => {\n        for (let key in _target) {\n          if (_target.hasOwnProperty(key)) {\n            let sourceValue = _source[key];\n            let targetValue = _target[key];\n            if (this.isPlainObject(targetValue)) {\n              if (this.isPlainObject(sourceValue)) {\n                copy(sourceValue, targetValue);\n              } else {\n                let obj = {};\n                _source[key] = obj;\n                copy(obj, targetValue);\n              }\n            } else {\n              _source[key] = targetValue;\n            }\n          }\n        }\n        return source;\n      };\n      return copy(source, target);\n    },\n\n    typeOf (value) {\n      if (T.Null.is(value)) {\n        return T.Null;\n      } else if (T.Undefined.is(value)) {\n        return T.Undefined;\n      } else if (T.String.is(value)) {\n        return T.String\n      } else if (T.Number.is(value)) {\n        return T.Number\n      } else if (T.Boolean.is(value)) {\n        return T.Boolean\n      } else if (T.Date.is(value)) {\n        return T.Date\n      } else if (T.Regex.is(value)) {\n        return T.Regex\n      } else if (T.Function.is(value)) {\n        return T.Function\n      } else if (T.Array.is(value)) {\n        if (value.length) {\n          return T.Array(this.typeOf(value[0]));\n        } else {\n          return T.Array();\n        }\n      } else if (T.Object.is(value)) {\n        return T.Object\n      } else if (T.Interface.is(value)) {\n        return T.Interface;\n      }\n      throw new AxialUnsupportedType(value);\n    },\n\n    isType (type) {\n      type = Array.isArray(type) ? type : [type];\n      const l = type.length;\n      for (let i = 0; i < l; i++) {\n        if (!(type[i] instanceof AxialType)) {\n          return false;\n        }\n      }\n      return true;\n    },\n\n    getObjectPaths (obj, includeBranchPaths) {\n      let keys = [];\n      let ref = null;\n      let path = null;\n      let walk = (o, p) => {\n        for (let k in o) {\n          if (o.hasOwnProperty(k)) {\n            ref = o[k];\n            path = p ? p + '.' + k : k;\n            if (this.isPlainObject(ref)) {\n              if (includeBranchPaths === true) {\n                keys.push(path);\n              }\n              walk(ref, path);\n            } else {\n              keys.push(path);\n            }\n          }\n        }\n      };\n      walk(obj);\n      return keys;\n    },\n\n    getObjectPathValues (obj, includeBranchPaths) {\n      let keyValues = [];\n      let ref = null;\n      let path = null;\n      let walk = (o, p) => {\n        for (let k in o) {\n          if (o.hasOwnProperty(k)) {\n            ref = o[k];\n            path = p ? p + '.' + k : k;\n            if (this.isPlainObject(ref)) {\n              if (includeBranchPaths === true) {\n                keyValues.push({path:path, value:ref, isBranch:true});\n              }\n              walk(ref, path);\n            } else {\n              keyValues.push({path:path, value:ref, isBranch:false});\n            }\n          }\n        }\n      };\n      walk(obj);\n      return keyValues;\n    },\n\n    getObjectAtPath (obj, path, shouldThrowIfNotFound) {\n      let steps = path.split('.');\n      let l = steps.length;\n      let ref = obj;\n      let k = null;\n      for (let i = 0; i < l; i++) {\n        k = steps[i];\n        ref = ref[k];\n        if (ref === null || typeof ref === 'undefined') {\n          if (shouldThrowIfNotFound === true) {\n            throw new AxialUndefinedValue(obj, path);\n          }\n          return ref;\n        }\n      }\n      return ref;\n    },\n\n    setObjectAtPath (obj, path, value) {\n      let ref = obj;\n      let steps = path.split('.');\n      let l = steps.length - 1;\n      let k = null;\n      for (let i = 0; i < l; i++) {\n        k = steps[i];\n        if (!ref.hasOwnProperty(k)) {\n          ref[k] = {};\n        }\n        ref = ref[k];\n      }\n      ref[steps[l]] = value;\n    },\n\n    multiSetObjectAtPath (obj, pathOrObject, value) {\n      let modifiedPaths = null;\n      if (this.isPlainObject(pathOrObject)) {\n        this.merge(obj, pathOrObject);\n        modifiedPaths = this.getObjectPaths(pathOrObject);\n      } else if (typeof pathOrObject === 'string') {\n        this.setObjectAtPath(obj, pathOrObject, value);\n        modifiedPaths = [pathOrObject];\n      }\n      return modifiedPaths;\n    },\n\n    expandDotSyntaxKeys (obj, resolver) {\n      for (let path in obj) {\n        if (obj.hasOwnProperty(path)) {\n          if (path.indexOf('.') > -1) {\n            const key = path.split('.')[0];\n            resolver(path, key, obj[path]);\n            delete obj[path];\n          }\n        }\n      }\n      return obj;\n    },\n\n    stringify (value) {\n      if (T.Object.is(value)) {\n        return '{' + Object.keys(value).map(k => k + ':<' + typeof value[k] + '>') + '}';\n      } else if (T.Function.is(value)) {\n        return 'function () {..}';\n      } else {\n        return JSON.stringify(value);\n      }\n    }\n  };\n\n  // -------------------------------------------------------------------------------------- Define Types\n  T = {\n    Null: new AxialNull,\n    Undefined: new AxialUndefined,\n    String: new AxialString,\n    Number: new AxialNumber,\n    Boolean: new AxialBoolean,\n    Date: new AxialDate,\n    Regex: new AxialRegex,\n    Function: new AxialFunction,\n    Array: function (type) {\n      const typeId = type ? type.name : '*';\n      let t = _arrayTypes[typeId];\n      if (t) {\n        return t;\n      } else {\n        t = _arrayTypes[typeId] = new AxialArray(type);\n        t._baseType = this.Array();\n        t._name = 'array[' + typeId + ']';\n      }\n      return t;\n    },\n    Object: new AxialObject,\n    Interface: new AxialInterface(null)\n  };\n\n  Object.keys(T).forEach(typeName => {\n    T[typeName].orUndefined = function () {\n      return [T[typeName], Axial.Undefined];\n    };\n    T[typeName].orNull = function () {\n      return [T[typeName], Axial.Null];\n    };\n    T[typeName].orUndefinedOrNull = function () {\n      return [T[typeName], Axial.Undefined, Axial.Null];\n    };\n  });\n\n  T.Array.is = function (value) {\n    return Array.isArray(value);\n  };\n  T.Array.Type = T.Array();\n\n  // -------------------------------------------------------------------------------------- Axial\n  let Axial = {\n    define (name, prototype) {\n      return new AxialInterface(name, prototype);\n    },\n    getInterface (name = 'null') {\n      const ifaceArray = _interfaces[name];\n      if (ifaceArray) {\n        return ifaceArray[ifaceArray.length - 1];\n      }\n    },\n    interfaceNames () {\n      return Object.keys(_interfaces).filter(name => _interfaces[name].isRootInterface);\n    },\n    interfaces () {\n      const o = {};\n      this.interfaceNames().forEach(name => o[name] = _interfaces[name]);\n      return o;\n    },\n    get instances () {\n      return _instances;\n    },\n    get bindings () {\n      return _bindings;\n    },\n    get bindingInfo () {\n      return this.bindings.map(binding => binding.instance._instanceId + ':' + binding.key);\n    },\n    bind (fn) {\n      _listeners.push(fn);\n    },\n    unbind (fn) {\n      if (fn) {\n        const index = _listeners.indexOf(fn);\n        _listeners.splice(index, 1);\n      } else {\n        _listeners.length = 0;\n      }\n    },\n    dispatch (eventData) {\n      const l = _listeners.length;\n      for (let i = 0; i < l; i++) {\n        _listeners[i](eventData);\n      }\n    },\n    Binding: AxialBinding,\n    PROXY_KEY: PROXY_KEY,\n    CONST: CONST\n  };\n\n  // export for testing\n  window.Axial = Axial;\n\n  // merge in types and errors\n  util.merge(Axial, T);\n  util.merge(Axial, Errors);\n\n  // extend Axial public interface\n  Axial.Instance = new AxialInstance();\n  Axial.util = util;\n\n  // extend misc types public interface\n  AxialInterface.prototype.new = AxialInterface.prototype.create;\n  AxialType.prototype.set = AxialType.prototype.defaultValue;\n\n  return Axial;\n})();\n\n\n// WEBPACK FOOTER //\n// ./lib/axial.js","module.exports = {\n  BLANK_INTERFACE_NAME: 'IFace',\n  PROXY_KEY: '$',\n  ARRAY_MEMBERS: [\n    'concat',\n    'copyWithin',\n    'entries',\n    'every',\n    'fill',\n    'filter',\n    'find',\n    'findIndex',\n    'forEach',\n    'includes',\n    'indexOf',\n    'join',\n    'keys',\n    'lastIndexOf',\n    'map',\n    'pop',\n    'push',\n    'reduce',\n    'reduceRight',\n    'reverse',\n    'shift',\n    'slice',\n    'some',\n    'sort',\n    'splice',\n    'toLocaleString',\n    'toSource',\n    'toString',\n    'unshift',\n    'values'\n  ],\n  ARRAY_MUTATORS: [\n    'copyWithin',\n    'fill',\n    'pop',\n    'push',\n    'reverse',\n    'shift',\n    'sort',\n    'splice',\n    'unshift'\n  ],\n  ARRAY_MUTATORS_REQUIRE_ARGS_VALIDATED: [\n    'fill',\n    'push',\n    'splice',\n    'unshift'\n  ]\n};\n\n\n// WEBPACK FOOTER //\n// ./lib/const.js","'use strict';\n\nvar _Expectation = require('./Expectation');\n\nvar _Expectation2 = _interopRequireDefault(_Expectation);\n\nvar _SpyUtils = require('./SpyUtils');\n\nvar _assert = require('./assert');\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nvar _extend = require('./extend');\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction expect(actual) {\n  return new _Expectation2.default(actual);\n}\n\nexpect.createSpy = _SpyUtils.createSpy;\nexpect.spyOn = _SpyUtils.spyOn;\nexpect.isSpy = _SpyUtils.isSpy;\nexpect.restoreSpies = _SpyUtils.restoreSpies;\nexpect.assert = _assert2.default;\nexpect.extend = _extend2.default;\n\nmodule.exports = expect;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/expect/lib/index.js\n// module id = 3\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _has = require('has');\n\nvar _has2 = _interopRequireDefault(_has);\n\nvar _tmatch = require('tmatch');\n\nvar _tmatch2 = _interopRequireDefault(_tmatch);\n\nvar _assert = require('./assert');\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nvar _SpyUtils = require('./SpyUtils');\n\nvar _TestUtils = require('./TestUtils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * An Expectation is a wrapper around an assertion that allows it to be written\n * in a more natural style, without the need to remember the order of arguments.\n * This helps prevent you from making mistakes when writing tests.\n */\n\nvar Expectation = function () {\n  function Expectation(actual) {\n    _classCallCheck(this, Expectation);\n\n    this.actual = actual;\n\n    if ((0, _TestUtils.isFunction)(actual)) {\n      this.context = null;\n      this.args = [];\n    }\n  }\n\n  _createClass(Expectation, [{\n    key: 'toExist',\n    value: function toExist(message) {\n      (0, _assert2.default)(this.actual, message || 'Expected %s to exist', this.actual);\n\n      return this;\n    }\n  }, {\n    key: 'toNotExist',\n    value: function toNotExist(message) {\n      (0, _assert2.default)(!this.actual, message || 'Expected %s to not exist', this.actual);\n\n      return this;\n    }\n  }, {\n    key: 'toBe',\n    value: function toBe(value, message) {\n      (0, _assert2.default)(this.actual === value, message || 'Expected %s to be %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toNotBe',\n    value: function toNotBe(value, message) {\n      (0, _assert2.default)(this.actual !== value, message || 'Expected %s to not be %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toEqual',\n    value: function toEqual(value, message) {\n      try {\n        (0, _assert2.default)((0, _TestUtils.isEqual)(this.actual, value), message || 'Expected %s to equal %s', this.actual, value);\n      } catch (error) {\n        // These attributes are consumed by Mocha to produce a diff output.\n        error.actual = this.actual;\n        error.expected = value;\n        error.showDiff = true;\n        throw error;\n      }\n\n      return this;\n    }\n  }, {\n    key: 'toNotEqual',\n    value: function toNotEqual(value, message) {\n      (0, _assert2.default)(!(0, _TestUtils.isEqual)(this.actual, value), message || 'Expected %s to not equal %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toThrow',\n    value: function toThrow(value, message) {\n      (0, _assert2.default)((0, _TestUtils.isFunction)(this.actual), 'The \"actual\" argument in expect(actual).toThrow() must be a function, %s was given', this.actual);\n\n      (0, _assert2.default)((0, _TestUtils.functionThrows)(this.actual, this.context, this.args, value), message || 'Expected %s to throw %s', this.actual, value || 'an error');\n\n      return this;\n    }\n  }, {\n    key: 'toNotThrow',\n    value: function toNotThrow(value, message) {\n      (0, _assert2.default)((0, _TestUtils.isFunction)(this.actual), 'The \"actual\" argument in expect(actual).toNotThrow() must be a function, %s was given', this.actual);\n\n      (0, _assert2.default)(!(0, _TestUtils.functionThrows)(this.actual, this.context, this.args, value), message || 'Expected %s to not throw %s', this.actual, value || 'an error');\n\n      return this;\n    }\n  }, {\n    key: 'toBeA',\n    value: function toBeA(value, message) {\n      (0, _assert2.default)((0, _TestUtils.isFunction)(value) || typeof value === 'string', 'The \"value\" argument in toBeA(value) must be a function or a string');\n\n      (0, _assert2.default)((0, _TestUtils.isA)(this.actual, value), message || 'Expected %s to be a %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toNotBeA',\n    value: function toNotBeA(value, message) {\n      (0, _assert2.default)((0, _TestUtils.isFunction)(value) || typeof value === 'string', 'The \"value\" argument in toNotBeA(value) must be a function or a string');\n\n      (0, _assert2.default)(!(0, _TestUtils.isA)(this.actual, value), message || 'Expected %s to not be a %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toMatch',\n    value: function toMatch(pattern, message) {\n      (0, _assert2.default)((0, _tmatch2.default)(this.actual, pattern), message || 'Expected %s to match %s', this.actual, pattern);\n\n      return this;\n    }\n  }, {\n    key: 'toNotMatch',\n    value: function toNotMatch(pattern, message) {\n      (0, _assert2.default)(!(0, _tmatch2.default)(this.actual, pattern), message || 'Expected %s to not match %s', this.actual, pattern);\n\n      return this;\n    }\n  }, {\n    key: 'toBeLessThan',\n    value: function toBeLessThan(value, message) {\n      (0, _assert2.default)(typeof this.actual === 'number', 'The \"actual\" argument in expect(actual).toBeLessThan() must be a number');\n\n      (0, _assert2.default)(typeof value === 'number', 'The \"value\" argument in toBeLessThan(value) must be a number');\n\n      (0, _assert2.default)(this.actual < value, message || 'Expected %s to be less than %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toBeLessThanOrEqualTo',\n    value: function toBeLessThanOrEqualTo(value, message) {\n      (0, _assert2.default)(typeof this.actual === 'number', 'The \"actual\" argument in expect(actual).toBeLessThanOrEqualTo() must be a number');\n\n      (0, _assert2.default)(typeof value === 'number', 'The \"value\" argument in toBeLessThanOrEqualTo(value) must be a number');\n\n      (0, _assert2.default)(this.actual <= value, message || 'Expected %s to be less than or equal to %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toBeGreaterThan',\n    value: function toBeGreaterThan(value, message) {\n      (0, _assert2.default)(typeof this.actual === 'number', 'The \"actual\" argument in expect(actual).toBeGreaterThan() must be a number');\n\n      (0, _assert2.default)(typeof value === 'number', 'The \"value\" argument in toBeGreaterThan(value) must be a number');\n\n      (0, _assert2.default)(this.actual > value, message || 'Expected %s to be greater than %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toBeGreaterThanOrEqualTo',\n    value: function toBeGreaterThanOrEqualTo(value, message) {\n      (0, _assert2.default)(typeof this.actual === 'number', 'The \"actual\" argument in expect(actual).toBeGreaterThanOrEqualTo() must be a number');\n\n      (0, _assert2.default)(typeof value === 'number', 'The \"value\" argument in toBeGreaterThanOrEqualTo(value) must be a number');\n\n      (0, _assert2.default)(this.actual >= value, message || 'Expected %s to be greater than or equal to %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toInclude',\n    value: function toInclude(value, compareValues, message) {\n      if (typeof compareValues === 'string') {\n        message = compareValues;\n        compareValues = null;\n      }\n\n      if (compareValues == null) compareValues = _TestUtils.isEqual;\n\n      var contains = false;\n\n      if ((0, _TestUtils.isArray)(this.actual)) {\n        contains = (0, _TestUtils.arrayContains)(this.actual, value, compareValues);\n      } else if ((0, _TestUtils.isObject)(this.actual)) {\n        contains = (0, _TestUtils.objectContains)(this.actual, value, compareValues);\n      } else if (typeof this.actual === 'string') {\n        contains = (0, _TestUtils.stringContains)(this.actual, value);\n      } else {\n        (0, _assert2.default)(false, 'The \"actual\" argument in expect(actual).toInclude() must be an array, object, or a string');\n      }\n\n      (0, _assert2.default)(contains, message || 'Expected %s to include %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toExclude',\n    value: function toExclude(value, compareValues, message) {\n      if (typeof compareValues === 'string') {\n        message = compareValues;\n        compareValues = null;\n      }\n\n      if (compareValues == null) compareValues = _TestUtils.isEqual;\n\n      var contains = false;\n\n      if ((0, _TestUtils.isArray)(this.actual)) {\n        contains = (0, _TestUtils.arrayContains)(this.actual, value, compareValues);\n      } else if ((0, _TestUtils.isObject)(this.actual)) {\n        contains = (0, _TestUtils.objectContains)(this.actual, value, compareValues);\n      } else if (typeof this.actual === 'string') {\n        contains = (0, _TestUtils.stringContains)(this.actual, value);\n      } else {\n        (0, _assert2.default)(false, 'The \"actual\" argument in expect(actual).toExclude() must be an array, object, or a string');\n      }\n\n      (0, _assert2.default)(!contains, message || 'Expected %s to exclude %s', this.actual, value);\n\n      return this;\n    }\n  }, {\n    key: 'toIncludeKeys',\n    value: function toIncludeKeys(keys, comparator, message) {\n      var _this = this;\n\n      if (typeof comparator === 'string') {\n        message = comparator;\n        comparator = null;\n      }\n\n      if (comparator == null) comparator = _has2.default;\n\n      (0, _assert2.default)(_typeof(this.actual) === 'object', 'The \"actual\" argument in expect(actual).toIncludeKeys() must be an object, not %s', this.actual);\n\n      (0, _assert2.default)((0, _TestUtils.isArray)(keys), 'The \"keys\" argument in expect(actual).toIncludeKeys(keys) must be an array, not %s', keys);\n\n      var contains = keys.every(function (key) {\n        return comparator(_this.actual, key);\n      });\n\n      (0, _assert2.default)(contains, message || 'Expected %s to include key(s) %s', this.actual, keys.join(', '));\n\n      return this;\n    }\n  }, {\n    key: 'toIncludeKey',\n    value: function toIncludeKey(key) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return this.toIncludeKeys.apply(this, [[key]].concat(args));\n    }\n  }, {\n    key: 'toExcludeKeys',\n    value: function toExcludeKeys(keys, comparator, message) {\n      var _this2 = this;\n\n      if (typeof comparator === 'string') {\n        message = comparator;\n        comparator = null;\n      }\n\n      if (comparator == null) comparator = _has2.default;\n\n      (0, _assert2.default)(_typeof(this.actual) === 'object', 'The \"actual\" argument in expect(actual).toExcludeKeys() must be an object, not %s', this.actual);\n\n      (0, _assert2.default)((0, _TestUtils.isArray)(keys), 'The \"keys\" argument in expect(actual).toIncludeKeys(keys) must be an array, not %s', keys);\n\n      var contains = keys.every(function (key) {\n        return comparator(_this2.actual, key);\n      });\n\n      (0, _assert2.default)(!contains, message || 'Expected %s to exclude key(s) %s', this.actual, keys.join(', '));\n\n      return this;\n    }\n  }, {\n    key: 'toExcludeKey',\n    value: function toExcludeKey(key) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      return this.toExcludeKeys.apply(this, [[key]].concat(args));\n    }\n  }, {\n    key: 'toHaveBeenCalled',\n    value: function toHaveBeenCalled(message) {\n      var spy = this.actual;\n\n      (0, _assert2.default)((0, _SpyUtils.isSpy)(spy), 'The \"actual\" argument in expect(actual).toHaveBeenCalled() must be a spy');\n\n      (0, _assert2.default)(spy.calls.length > 0, message || 'spy was not called');\n\n      return this;\n    }\n  }, {\n    key: 'toHaveBeenCalledWith',\n    value: function toHaveBeenCalledWith() {\n      for (var _len3 = arguments.length, expectedArgs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        expectedArgs[_key3] = arguments[_key3];\n      }\n\n      var spy = this.actual;\n\n      (0, _assert2.default)((0, _SpyUtils.isSpy)(spy), 'The \"actual\" argument in expect(actual).toHaveBeenCalledWith() must be a spy');\n\n      (0, _assert2.default)(spy.calls.some(function (call) {\n        return (0, _TestUtils.isEqual)(call.arguments, expectedArgs);\n      }), 'spy was never called with %s', expectedArgs);\n\n      return this;\n    }\n  }, {\n    key: 'toNotHaveBeenCalled',\n    value: function toNotHaveBeenCalled(message) {\n      var spy = this.actual;\n\n      (0, _assert2.default)((0, _SpyUtils.isSpy)(spy), 'The \"actual\" argument in expect(actual).toNotHaveBeenCalled() must be a spy');\n\n      (0, _assert2.default)(spy.calls.length === 0, message || 'spy was not supposed to be called');\n\n      return this;\n    }\n  }]);\n\n  return Expectation;\n}();\n\nvar deprecate = function deprecate(fn, message) {\n  var alreadyWarned = false;\n\n  return function () {\n    if (!alreadyWarned) {\n      alreadyWarned = true;\n      console.warn(message);\n    }\n\n    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    return fn.apply(this, args);\n  };\n};\n\nExpectation.prototype.withContext = deprecate(function (context) {\n  (0, _assert2.default)((0, _TestUtils.isFunction)(this.actual), 'The \"actual\" argument in expect(actual).withContext() must be a function');\n\n  this.context = context;\n\n  return this;\n}, '\\nwithContext is deprecated; use a closure instead.\\n\\n  expect(fn).withContext(context).toThrow()\\n\\nbecomes\\n\\n  expect(() => fn.call(context)).toThrow()\\n');\n\nExpectation.prototype.withArgs = deprecate(function () {\n  var _args;\n\n  (0, _assert2.default)((0, _TestUtils.isFunction)(this.actual), 'The \"actual\" argument in expect(actual).withArgs() must be a function');\n\n  if (arguments.length) this.args = (_args = this.args).concat.apply(_args, arguments);\n\n  return this;\n}, '\\nwithArgs is deprecated; use a closure instead.\\n\\n  expect(fn).withArgs(a, b, c).toThrow()\\n\\nbecomes\\n\\n  expect(() => fn(a, b, c)).toThrow()\\n');\n\nvar aliases = {\n  toBeAn: 'toBeA',\n  toNotBeAn: 'toNotBeA',\n  toBeTruthy: 'toExist',\n  toBeFalsy: 'toNotExist',\n  toBeFewerThan: 'toBeLessThan',\n  toBeMoreThan: 'toBeGreaterThan',\n  toContain: 'toInclude',\n  toNotContain: 'toExclude',\n  toNotInclude: 'toExclude',\n  toContainKeys: 'toIncludeKeys',\n  toNotContainKeys: 'toExcludeKeys',\n  toNotIncludeKeys: 'toExcludeKeys',\n  toContainKey: 'toIncludeKey',\n  toNotContainKey: 'toExcludeKey',\n  toNotIncludeKey: 'toExcludeKey'\n};\n\nfor (var alias in aliases) {\n  if (aliases.hasOwnProperty(alias)) Expectation.prototype[alias] = Expectation.prototype[aliases[alias]];\n}exports.default = Expectation;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/expect/lib/Expectation.js\n// module id = 4\n// module chunks = 0","var bind = require('function-bind');\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/has/src/index.js\n// module id = 5\n// module chunks = 0","var implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/function-bind/index.js\n// module id = 6\n// module chunks = 0","var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/function-bind/implementation.js\n// module id = 7\n// module chunks = 0","'use strict'\n\nfunction isArguments (obj) {\n  return Object.prototype.toString.call(obj) === '[object Arguments]'\n}\n\nmodule.exports = match\n\nfunction match (obj, pattern) {\n  return match_(obj, pattern, [], [])\n}\n\n/* istanbul ignore next */\nvar log = (/\\btmatch\\b/.test(process.env.NODE_DEBUG || '')) ?\n  console.error : function () {}\n\nfunction match_ (obj, pattern, ca, cb) {\n  log('TMATCH', typeof obj, pattern)\n  if (obj == pattern) {\n    log('TMATCH same object or simple value, or problem')\n    // if one is object, and the other isn't, then this is bogus\n    if (obj === null || pattern === null) {\n      return true\n\n    } else if (typeof obj === 'object' && typeof pattern === 'object') {\n      return true\n\n    } else if (typeof obj === 'object' && typeof pattern !== 'object') {\n      return false\n\n    } else if (typeof obj !== 'object' && typeof pattern === 'object') {\n      return false\n\n    } else {\n      return true\n    }\n\n  } else if (obj === null || pattern === null) {\n    log('TMATCH null test, already failed ==')\n    return false\n\n  } else if (typeof obj === 'string' && pattern instanceof RegExp) {\n    log('TMATCH string~=regexp test')\n    return pattern.test(obj)\n\n  } else if (typeof obj === 'string' && typeof pattern === 'string' && pattern) {\n    log('TMATCH string~=string test')\n    return obj.indexOf(pattern) !== -1\n\n  } else if (obj instanceof Date && pattern instanceof Date) {\n    log('TMATCH date test')\n    return obj.getTime() === pattern.getTime()\n\n  } else if (obj instanceof Date && typeof pattern === 'string') {\n    log('TMATCH date~=string test')\n    return obj.getTime() === new Date(pattern).getTime()\n\n  } else if (isArguments(obj) || isArguments(pattern)) {\n    log('TMATCH arguments test')\n    var slice = Array.prototype.slice\n    return match_(slice.call(obj), slice.call(pattern), ca, cb)\n\n  } else if (pattern === Buffer) {\n    log('TMATCH Buffer ctor')\n    return Buffer.isBuffer(obj)\n\n  } else if (pattern === Function) {\n    log('TMATCH Function ctor')\n    return typeof obj === 'function'\n\n  } else if (pattern === Number) {\n    log('TMATCH Number ctor (finite, not NaN)')\n    return typeof obj === 'number' && obj === obj && isFinite(obj)\n\n  } else if (pattern !== pattern) {\n    log('TMATCH NaN')\n    return obj !== obj\n\n  } else if (pattern === String) {\n    log('TMATCH String ctor')\n    return typeof obj === 'string'\n\n  } else if (pattern === Boolean) {\n    log('TMATCH Boolean ctor')\n    return typeof obj === 'boolean'\n\n  } else if (pattern === Array) {\n    log('TMATCH Array ctor', pattern, Array.isArray(obj))\n    return Array.isArray(obj)\n\n  } else if (typeof pattern === 'function' && typeof obj === 'object') {\n    log('TMATCH object~=function')\n    return obj instanceof pattern\n\n  } else if (typeof obj !== 'object' || typeof pattern !== 'object') {\n    log('TMATCH obj is not object, pattern is not object, false')\n    return false\n\n  } else if (obj instanceof RegExp && pattern instanceof RegExp) {\n    log('TMATCH regexp~=regexp test')\n    return obj.source === pattern.source &&\n      obj.global === pattern.global &&\n      obj.multiline === pattern.multiline &&\n      obj.lastIndex === pattern.lastIndex &&\n      obj.ignoreCase === pattern.ignoreCase\n\n  } else if (Buffer.isBuffer(obj) && Buffer.isBuffer(pattern)) {\n    log('TMATCH buffer test')\n    if (obj.equals) {\n      return obj.equals(pattern)\n    } else {\n      if (obj.length !== pattern.length) return false\n\n      for (var j = 0; j < obj.length; j++) if (obj[j] != pattern[j]) return false\n\n      return true\n    }\n\n  } else {\n    // both are objects.  interesting case!\n    log('TMATCH object~=object test')\n    var kobj = Object.keys(obj)\n    var kpat = Object.keys(pattern)\n    log('  TMATCH patternkeys=%j objkeys=%j', kpat, kobj)\n\n    // don't bother with stack acrobatics if there's nothing there\n    if (kobj.length === 0 && kpat.length === 0) return true\n\n    // if we've seen this exact pattern and object already, then\n    // it means that pattern and obj have matching cyclicalness\n    // however, non-cyclical patterns can match cyclical objects\n    log('  TMATCH check seen objects...')\n    var cal = ca.length\n    while (cal--) if (ca[cal] === obj && cb[cal] === pattern) return true\n    ca.push(obj); cb.push(pattern)\n    log('  TMATCH not seen previously')\n\n    var key\n    for (var l = kpat.length - 1; l >= 0; l--) {\n      key = kpat[l]\n      log('  TMATCH test obj[%j]', key, obj[key], pattern[key])\n      if (!match_(obj[key], pattern[key], ca, cb)) return false\n    }\n\n    ca.pop()\n    cb.pop()\n\n    log('  TMATCH object pass')\n    return true\n  }\n\n  /* istanbul ignore next */\n  throw new Error('impossible to reach this point')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/tmatch/index.js\n// module id = 8\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 9\n// module chunks = 0","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/buffer/index.js\n// module id = 10\n// module chunks = 0","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = 11\n// module chunks = 0","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ieee754/index.js\n// module id = 12\n// module chunks = 0","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/buffer/~/isarray/index.js\n// module id = 13\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _objectInspect = require('object-inspect');\n\nvar _objectInspect2 = _interopRequireDefault(_objectInspect);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar formatString = function formatString(string, args) {\n  var index = 0;\n  return string.replace(/%s/g, function () {\n    return (0, _objectInspect2.default)(args[index++]);\n  });\n};\n\nvar assert = function assert(condition, createMessage) {\n  for (var _len = arguments.length, extraArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    extraArgs[_key - 2] = arguments[_key];\n  }\n\n  if (condition) return;\n\n  var message = typeof createMessage === 'string' ? formatString(createMessage, extraArgs) : createMessage(extraArgs);\n\n  throw new Error(message);\n};\n\nexports.default = assert;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/expect/lib/assert.js\n// module id = 14\n// module chunks = 0","var hasMap = typeof Map === 'function' && Map.prototype;\nvar mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;\nvar mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;\nvar mapForEach = hasMap && Map.prototype.forEach;\nvar hasSet = typeof Set === 'function' && Set.prototype;\nvar setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;\nvar setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;\nvar setForEach = hasSet && Set.prototype.forEach;\nvar booleanValueOf = Boolean.prototype.valueOf;\n\nmodule.exports = function inspect_ (obj, opts, depth, seen) {\n    if (!opts) opts = {};\n    \n    var maxDepth = opts.depth === undefined ? 5 : opts.depth;\n    if (depth === undefined) depth = 0;\n    if (depth >= maxDepth && maxDepth > 0 && obj && typeof obj === 'object') {\n        return '[Object]';\n    }\n    \n    if (seen === undefined) seen = [];\n    else if (indexOf(seen, obj) >= 0) {\n        return '[Circular]';\n    }\n    \n    function inspect (value, from) {\n        if (from) {\n            seen = seen.slice();\n            seen.push(from);\n        }\n        return inspect_(value, opts, depth + 1, seen);\n    }\n    \n    if (typeof obj === 'string') {\n        return inspectString(obj);\n    }\n    else if (typeof obj === 'function') {\n        var name = nameOf(obj);\n        return '[Function' + (name ? ': ' + name : '') + ']';\n    }\n    else if (obj === null) {\n        return 'null';\n    }\n    else if (isSymbol(obj)) {\n        var symString = Symbol.prototype.toString.call(obj);\n        return typeof obj === 'object' ? 'Object(' + symString + ')' : symString;\n    }\n    else if (isElement(obj)) {\n        var s = '<' + String(obj.nodeName).toLowerCase();\n        var attrs = obj.attributes || [];\n        for (var i = 0; i < attrs.length; i++) {\n            s += ' ' + attrs[i].name + '=\"' + quote(attrs[i].value) + '\"';\n        }\n        s += '>';\n        if (obj.childNodes && obj.childNodes.length) s += '...';\n        s += '</' + String(obj.nodeName).toLowerCase() + '>';\n        return s;\n    }\n    else if (isArray(obj)) {\n        if (obj.length === 0) return '[]';\n        var xs = Array(obj.length);\n        for (var i = 0; i < obj.length; i++) {\n            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';\n        }\n        return '[ ' + xs.join(', ') + ' ]';\n    }\n    else if (isError(obj)) {\n        var parts = [];\n        for (var key in obj) {\n            if (!has(obj, key)) continue;\n            \n            if (/[^\\w$]/.test(key)) {\n                parts.push(inspect(key) + ': ' + inspect(obj[key]));\n            }\n            else {\n                parts.push(key + ': ' + inspect(obj[key]));\n            }\n        }\n        if (parts.length === 0) return '[' + obj + ']';\n        return '{ [' + obj + '] ' + parts.join(', ') + ' }';\n    }\n    else if (typeof obj === 'object' && typeof obj.inspect === 'function') {\n        return obj.inspect();\n    }\n    else if (isMap(obj)) {\n        var parts = [];\n        mapForEach.call(obj, function (value, key) {\n            parts.push(inspect(key, obj) + ' => ' + inspect(value, obj));\n        });\n        return 'Map (' + mapSize.call(obj) + ') {' + parts.join(', ') + '}';\n    }\n    else if (isSet(obj)) {\n        var parts = [];\n        setForEach.call(obj, function (value ) {\n            parts.push(inspect(value, obj));\n        });\n        return 'Set (' + setSize.call(obj) + ') {' + parts.join(', ') + '}';\n    }\n    else if (typeof obj !== 'object') {\n        return String(obj);\n    }\n    else if (isNumber(obj)) {\n        return 'Object(' + Number(obj) + ')';\n    }\n    else if (isBoolean(obj)) {\n        return 'Object(' + booleanValueOf.call(obj) + ')';\n    }\n    else if (isString(obj)) {\n        return 'Object(' + inspect(String(obj)) + ')';\n    }\n    else if (!isDate(obj) && !isRegExp(obj)) {\n        var xs = [], keys = [];\n        for (var key in obj) {\n            if (has(obj, key)) keys.push(key);\n        }\n        keys.sort();\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            if (/[^\\w$]/.test(key)) {\n                xs.push(inspect(key) + ': ' + inspect(obj[key], obj));\n            }\n            else xs.push(key + ': ' + inspect(obj[key], obj));\n        }\n        if (xs.length === 0) return '{}';\n        return '{ ' + xs.join(', ') + ' }';\n    }\n    else return String(obj);\n};\n\nfunction quote (s) {\n    return String(s).replace(/\"/g, '&quot;');\n}\n\nfunction isArray (obj) { return toStr(obj) === '[object Array]' }\nfunction isDate (obj) { return toStr(obj) === '[object Date]' }\nfunction isRegExp (obj) { return toStr(obj) === '[object RegExp]' }\nfunction isError (obj) { return toStr(obj) === '[object Error]' }\nfunction isSymbol (obj) { return toStr(obj) === '[object Symbol]' }\nfunction isString (obj) { return toStr(obj) === '[object String]' }\nfunction isNumber (obj) { return toStr(obj) === '[object Number]' }\nfunction isBoolean (obj) { return toStr(obj) === '[object Boolean]' }\n\nvar hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };\nfunction has (obj, key) {\n    return hasOwn.call(obj, key);\n}\n\nfunction toStr (obj) {\n    return Object.prototype.toString.call(obj);\n}\n\nfunction nameOf (f) {\n    if (f.name) return f.name;\n    var m = f.toString().match(/^function\\s*([\\w$]+)/);\n    if (m) return m[1];\n}\n\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0, l = xs.length; i < l; i++) {\n        if (xs[i] === x) return i;\n    }\n    return -1;\n}\n\nfunction isMap (x) {\n    if (!mapSize) {\n        return false;\n    }\n    try {\n        mapSize.call(x);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nfunction isSet (x) {\n    if (!setSize) {\n        return false;\n    }\n    try {\n        setSize.call(x);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nfunction isElement (x) {\n    if (!x || typeof x !== 'object') return false;\n    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {\n        return true;\n    }\n    return typeof x.nodeName === 'string'\n        && typeof x.getAttribute === 'function'\n    ;\n}\n\nfunction inspectString (str) {\n    var s = str.replace(/(['\\\\])/g, '\\\\$1').replace(/[\\x00-\\x1f]/g, lowbyte);\n    return \"'\" + s + \"'\";\n    \n    function lowbyte (c) {\n        var n = c.charCodeAt(0);\n        var x = { 8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r' }[n];\n        if (x) return '\\\\' + x;\n        return '\\\\x' + (n < 0x10 ? '0' : '') + n.toString(16);\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/object-inspect/index.js\n// module id = 15\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.spyOn = exports.createSpy = exports.restoreSpies = exports.isSpy = undefined;\n\nvar _defineProperties = require('define-properties');\n\nvar _assert = require('./assert');\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nvar _TestUtils = require('./TestUtils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /*eslint-disable prefer-rest-params, no-underscore-dangle*/\n\n\nvar noop = function noop() {};\n\nvar supportsConfigurableFnLength = _defineProperties.supportsDescriptors && Object.getOwnPropertyDescriptor(function () {}, 'length').configurable;\n\nvar isSpy = exports.isSpy = function isSpy(object) {\n  return object && object.__isSpy === true;\n};\n\nvar spies = [];\n\nvar restoreSpies = exports.restoreSpies = function restoreSpies() {\n  for (var i = spies.length - 1; i >= 0; i--) {\n    spies[i].restore();\n  }spies = [];\n};\n\nvar createSpy = exports.createSpy = function createSpy(fn) {\n  var restore = arguments.length <= 1 || arguments[1] === undefined ? noop : arguments[1];\n\n  if (fn == null) fn = noop;\n\n  (0, _assert2.default)((0, _TestUtils.isFunction)(fn), 'createSpy needs a function');\n\n  var targetFn = void 0,\n      thrownValue = void 0,\n      returnValue = void 0,\n      spy = void 0;\n\n  function spyLogic() {\n    spy.calls.push({\n      context: this,\n      arguments: Array.prototype.slice.call(arguments, 0)\n    });\n\n    if (targetFn) return targetFn.apply(this, arguments);\n\n    if (thrownValue) throw thrownValue;\n\n    return returnValue;\n  }\n\n  if (supportsConfigurableFnLength) {\n    spy = Object.defineProperty(spyLogic, 'length', { value: fn.length, writable: false, enumerable: false, configurable: true });\n  } else {\n    spy = new Function('spy', 'return function(' + // eslint-disable-line no-new-func\n    [].concat(_toConsumableArray(Array(fn.length))).map(function (_, i) {\n      return '_' + i;\n    }).join(',') + ') {\\n      return spy.apply(this, arguments)\\n    }')(spyLogic);\n  }\n\n  spy.calls = [];\n\n  spy.andCall = function (otherFn) {\n    targetFn = otherFn;\n    return spy;\n  };\n\n  spy.andCallThrough = function () {\n    return spy.andCall(fn);\n  };\n\n  spy.andThrow = function (value) {\n    thrownValue = value;\n    return spy;\n  };\n\n  spy.andReturn = function (value) {\n    returnValue = value;\n    return spy;\n  };\n\n  spy.getLastCall = function () {\n    return spy.calls[spy.calls.length - 1];\n  };\n\n  spy.reset = function () {\n    spy.calls = [];\n  };\n\n  spy.restore = spy.destroy = restore;\n\n  spy.__isSpy = true;\n\n  spies.push(spy);\n\n  return spy;\n};\n\nvar spyOn = exports.spyOn = function spyOn(object, methodName) {\n  var original = object[methodName];\n\n  if (!isSpy(original)) {\n    (0, _assert2.default)((0, _TestUtils.isFunction)(original), 'Cannot spyOn the %s property; it is not a function', methodName);\n\n    object[methodName] = createSpy(original, function () {\n      object[methodName] = original;\n    });\n  }\n\n  return object[methodName];\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/expect/lib/SpyUtils.js\n// module id = 16\n// module chunks = 0","'use strict';\n\nvar keys = require('object-keys');\nvar foreach = require('foreach');\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';\n\nvar toStr = Object.prototype.toString;\n\nvar isFunction = function (fn) {\n\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\n};\n\nvar arePropertyDescriptorsSupported = function () {\n\tvar obj = {};\n\ttry {\n\t\tObject.defineProperty(obj, 'x', { enumerable: false, value: obj });\n        /* eslint-disable no-unused-vars, no-restricted-syntax */\n        for (var _ in obj) { return false; }\n        /* eslint-enable no-unused-vars, no-restricted-syntax */\n\t\treturn obj.x === obj;\n\t} catch (e) { /* this is IE 8. */\n\t\treturn false;\n\t}\n};\nvar supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();\n\nvar defineProperty = function (object, name, value, predicate) {\n\tif (name in object && (!isFunction(predicate) || !predicate())) {\n\t\treturn;\n\t}\n\tif (supportsDescriptors) {\n\t\tObject.defineProperty(object, name, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: value,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\tobject[name] = value;\n\t}\n};\n\nvar defineProperties = function (object, map) {\n\tvar predicates = arguments.length > 2 ? arguments[2] : {};\n\tvar props = keys(map);\n\tif (hasSymbols) {\n\t\tprops = props.concat(Object.getOwnPropertySymbols(map));\n\t}\n\tforeach(props, function (name) {\n\t\tdefineProperty(object, name, map[name], predicates[name]);\n\t});\n};\n\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\n\nmodule.exports = defineProperties;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/define-properties/index.js\n// module id = 17\n// module chunks = 0","'use strict';\n\n// modified from https://github.com/es-shims/es5-shim\nvar has = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar slice = Array.prototype.slice;\nvar isArgs = require('./isArguments');\nvar isEnumerable = Object.prototype.propertyIsEnumerable;\nvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\nvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\nvar dontEnums = [\n\t'toString',\n\t'toLocaleString',\n\t'valueOf',\n\t'hasOwnProperty',\n\t'isPrototypeOf',\n\t'propertyIsEnumerable',\n\t'constructor'\n];\nvar equalsConstructorPrototype = function (o) {\n\tvar ctor = o.constructor;\n\treturn ctor && ctor.prototype === o;\n};\nvar excludedKeys = {\n\t$console: true,\n\t$external: true,\n\t$frame: true,\n\t$frameElement: true,\n\t$frames: true,\n\t$innerHeight: true,\n\t$innerWidth: true,\n\t$outerHeight: true,\n\t$outerWidth: true,\n\t$pageXOffset: true,\n\t$pageYOffset: true,\n\t$parent: true,\n\t$scrollLeft: true,\n\t$scrollTop: true,\n\t$scrollX: true,\n\t$scrollY: true,\n\t$self: true,\n\t$webkitIndexedDB: true,\n\t$webkitStorageInfo: true,\n\t$window: true\n};\nvar hasAutomationEqualityBug = (function () {\n\t/* global window */\n\tif (typeof window === 'undefined') { return false; }\n\tfor (var k in window) {\n\t\ttry {\n\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\n\t\t\t\ttry {\n\t\t\t\t\tequalsConstructorPrototype(window[k]);\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}());\nvar equalsConstructorPrototypeIfNotBuggy = function (o) {\n\t/* global window */\n\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\n\t\treturn equalsConstructorPrototype(o);\n\t}\n\ttry {\n\t\treturn equalsConstructorPrototype(o);\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\nvar keysShim = function keys(object) {\n\tvar isObject = object !== null && typeof object === 'object';\n\tvar isFunction = toStr.call(object) === '[object Function]';\n\tvar isArguments = isArgs(object);\n\tvar isString = isObject && toStr.call(object) === '[object String]';\n\tvar theKeys = [];\n\n\tif (!isObject && !isFunction && !isArguments) {\n\t\tthrow new TypeError('Object.keys called on a non-object');\n\t}\n\n\tvar skipProto = hasProtoEnumBug && isFunction;\n\tif (isString && object.length > 0 && !has.call(object, 0)) {\n\t\tfor (var i = 0; i < object.length; ++i) {\n\t\t\ttheKeys.push(String(i));\n\t\t}\n\t}\n\n\tif (isArguments && object.length > 0) {\n\t\tfor (var j = 0; j < object.length; ++j) {\n\t\t\ttheKeys.push(String(j));\n\t\t}\n\t} else {\n\t\tfor (var name in object) {\n\t\t\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\n\t\t\t\ttheKeys.push(String(name));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hasDontEnumBug) {\n\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\n\n\t\tfor (var k = 0; k < dontEnums.length; ++k) {\n\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\n\t\t\t\ttheKeys.push(dontEnums[k]);\n\t\t\t}\n\t\t}\n\t}\n\treturn theKeys;\n};\n\nkeysShim.shim = function shimObjectKeys() {\n\tif (Object.keys) {\n\t\tvar keysWorksWithArguments = (function () {\n\t\t\t// Safari 5.0 bug\n\t\t\treturn (Object.keys(arguments) || '').length === 2;\n\t\t}(1, 2));\n\t\tif (!keysWorksWithArguments) {\n\t\t\tvar originalKeys = Object.keys;\n\t\t\tObject.keys = function keys(object) {\n\t\t\t\tif (isArgs(object)) {\n\t\t\t\t\treturn originalKeys(slice.call(object));\n\t\t\t\t} else {\n\t\t\t\t\treturn originalKeys(object);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t} else {\n\t\tObject.keys = keysShim;\n\t}\n\treturn Object.keys || keysShim;\n};\n\nmodule.exports = keysShim;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/object-keys/index.js\n// module id = 18\n// module chunks = 0","'use strict';\n\nvar toStr = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toStr.call(value);\n\tvar isArgs = str === '[object Arguments]';\n\tif (!isArgs) {\n\t\tisArgs = str !== '[object Array]' &&\n\t\t\tvalue !== null &&\n\t\t\ttypeof value === 'object' &&\n\t\t\ttypeof value.length === 'number' &&\n\t\t\tvalue.length >= 0 &&\n\t\t\ttoStr.call(value.callee) === '[object Function]';\n\t}\n\treturn isArgs;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/object-keys/isArguments.js\n// module id = 19\n// module chunks = 0","\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== '[object Function]') {\n        throw new TypeError('iterator must be a function');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/foreach/index.js\n// module id = 20\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stringContains = exports.objectContains = exports.arrayContains = exports.functionThrows = exports.isA = exports.isObject = exports.isArray = exports.isFunction = exports.isEqual = exports.whyNotEqual = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _isRegex = require('is-regex');\n\nvar _isRegex2 = _interopRequireDefault(_isRegex);\n\nvar _why = require('is-equal/why');\n\nvar _why2 = _interopRequireDefault(_why);\n\nvar _objectKeys = require('object-keys');\n\nvar _objectKeys2 = _interopRequireDefault(_objectKeys);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Returns the reason why the given arguments are not *conceptually*\n * equal, if any; the empty string otherwise.\n */\nvar whyNotEqual = exports.whyNotEqual = function whyNotEqual(a, b) {\n  return a == b ? '' : (0, _why2.default)(a, b);\n};\n\n/**\n * Returns true if the given arguments are *conceptually* equal.\n */\nvar isEqual = exports.isEqual = function isEqual(a, b) {\n  return whyNotEqual(a, b) === '';\n};\n\n/**\n * Returns true if the given object is a function.\n */\nvar isFunction = exports.isFunction = function isFunction(object) {\n  return typeof object === 'function';\n};\n\n/**\n * Returns true if the given object is an array.\n */\nvar isArray = exports.isArray = function isArray(object) {\n  return Array.isArray(object);\n};\n\n/**\n * Returns true if the given object is an object.\n */\nvar isObject = exports.isObject = function isObject(object) {\n  return object && !isArray(object) && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object';\n};\n\n/**\n * Returns true if the given object is an instanceof value\n * or its typeof is the given value.\n */\nvar isA = exports.isA = function isA(object, value) {\n  if (isFunction(value)) return object instanceof value;\n\n  if (value === 'array') return Array.isArray(object);\n\n  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === value;\n};\n\n/**\n * Returns true if the given function throws the given value\n * when invoked. The value may be:\n *\n * - undefined, to merely assert there was a throw\n * - a constructor function, for comparing using instanceof\n * - a regular expression, to compare with the error message\n * - a string, to find in the error message\n */\nvar functionThrows = exports.functionThrows = function functionThrows(fn, context, args, value) {\n  try {\n    fn.apply(context, args);\n  } catch (error) {\n    if (value == null) return true;\n\n    if (isFunction(value) && error instanceof value) return true;\n\n    var message = error.message || error;\n\n    if (typeof message === 'string') {\n      if ((0, _isRegex2.default)(value) && value.test(error.message)) return true;\n\n      if (typeof value === 'string' && message.indexOf(value) !== -1) return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Returns true if the given array contains the value, false\n * otherwise. The compareValues function must return false to\n * indicate a non-match.\n */\nvar arrayContains = exports.arrayContains = function arrayContains(array, value, compareValues) {\n  return array.some(function (item) {\n    return compareValues(item, value) !== false;\n  });\n};\n\nvar ownEnumerableKeys = function ownEnumerableKeys(object) {\n  if ((typeof Reflect === 'undefined' ? 'undefined' : _typeof(Reflect)) === 'object' && typeof Reflect.ownKeys === 'function') {\n    return Reflect.ownKeys(object).filter(function (key) {\n      return Object.getOwnPropertyDescriptor(object, key).enumerable;\n    });\n  }\n\n  if (typeof Object.getOwnPropertySymbols === 'function') {\n    return Object.getOwnPropertySymbols(object).filter(function (key) {\n      return Object.getOwnPropertyDescriptor(object, key).enumerable;\n    }).concat((0, _objectKeys2.default)(object));\n  }\n\n  return (0, _objectKeys2.default)(object);\n};\n\n/**\n * Returns true if the given object contains the value, false\n * otherwise. The compareValues function must return false to\n * indicate a non-match.\n */\nvar objectContains = exports.objectContains = function objectContains(object, value, compareValues) {\n  return ownEnumerableKeys(value).every(function (k) {\n    if (isObject(object[k]) && isObject(value[k])) return objectContains(object[k], value[k], compareValues);\n\n    return compareValues(object[k], value[k]);\n  });\n};\n\n/**\n * Returns true if the given string contains the value, false otherwise.\n */\nvar stringContains = exports.stringContains = function stringContains(string, value) {\n  return string.indexOf(value) !== -1;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/expect/lib/TestUtils.js\n// module id = 21\n// module chunks = 0","'use strict';\n\nvar regexExec = RegExp.prototype.exec;\nvar tryRegexExec = function tryRegexExec(value) {\n\ttry {\n\t\tregexExec.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar regexClass = '[object RegExp]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isRegex(value) {\n\tif (typeof value !== 'object') { return false; }\n\treturn hasToStringTag ? tryRegexExec(value) : toStr.call(value) === regexClass;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/is-regex/index.js\n// module id = 22\n// module chunks = 0","'use strict';\n\nvar ObjectPrototype = Object.prototype;\nvar toStr = ObjectPrototype.toString;\nvar booleanValue = Boolean.prototype.valueOf;\nvar has = require('has');\nvar isArrowFunction = require('is-arrow-function');\nvar isBoolean = require('is-boolean-object');\nvar isDate = require('is-date-object');\nvar isGenerator = require('is-generator-function');\nvar isNumber = require('is-number-object');\nvar isRegex = require('is-regex');\nvar isString = require('is-string');\nvar isSymbol = require('is-symbol');\nvar isCallable = require('is-callable');\n\nvar isProto = Object.prototype.isPrototypeOf;\n\nvar foo = function foo() {};\nvar functionsHaveNames = foo.name === 'foo';\n\nvar symbolValue = typeof Symbol === 'function' ? Symbol.prototype.valueOf : null;\nvar symbolIterator = require('./getSymbolIterator')();\n\nvar collectionsForEach = require('./getCollectionsForEach')();\n\nvar getPrototypeOf = Object.getPrototypeOf;\nif (!getPrototypeOf) {\n\t/* eslint-disable no-proto */\n\tif (typeof 'test'.__proto__ === 'object') {\n\t\tgetPrototypeOf = function (obj) {\n\t\t\treturn obj.__proto__;\n\t\t};\n\t} else {\n\t\tgetPrototypeOf = function (obj) {\n\t\t\tvar constructor = obj.constructor,\n\t\t\t\toldConstructor;\n\t\t\tif (has(obj, 'constructor')) {\n\t\t\t\toldConstructor = constructor;\n\t\t\t\tif (!(delete obj.constructor)) { // reset constructor\n\t\t\t\t\treturn null; // can't delete obj.constructor, return null\n\t\t\t\t}\n\t\t\t\tconstructor = obj.constructor; // get real constructor\n\t\t\t\tobj.constructor = oldConstructor; // restore constructor\n\t\t\t}\n\t\t\treturn constructor ? constructor.prototype : ObjectPrototype; // needed for IE\n\t\t};\n\t}\n\t/* eslint-enable no-proto */\n}\n\nvar isArray = Array.isArray || function (value) {\n\treturn toStr.call(value) === '[object Array]';\n};\n\nvar normalizeFnWhitespace = function normalizeFnWhitespace(fnStr) {\n\t// this is needed in IE 9, at least, which has inconsistencies here.\n\treturn fnStr.replace(/^function ?\\(/, 'function (').replace('){', ') {');\n};\n\nvar tryMapSetEntries = function tryMapSetEntries(collection) {\n\tvar foundEntries = [];\n\ttry {\n\t\tcollectionsForEach.Map.call(collection, function (key, value) {\n\t\t\tfoundEntries.push([key, value]);\n\t\t});\n\t} catch (notMap) {\n\t\ttry {\n\t\t\tcollectionsForEach.Set.call(collection, function (value) {\n\t\t\t\tfoundEntries.push([value]);\n\t\t\t});\n\t\t} catch (notSet) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn foundEntries;\n};\n\nmodule.exports = function whyNotEqual(value, other) {\n\tif (value === other) { return ''; }\n\tif (value == null || other == null) {\n\t\treturn value === other ? '' : String(value) + ' !== ' + String(other);\n\t}\n\n\tvar valToStr = toStr.call(value);\n\tvar otherToStr = toStr.call(other);\n\tif (valToStr !== otherToStr) {\n\t\treturn 'toStringTag is not the same: ' + valToStr + ' !== ' + otherToStr;\n\t}\n\n\tvar valIsBool = isBoolean(value);\n\tvar otherIsBool = isBoolean(other);\n\tif (valIsBool || otherIsBool) {\n\t\tif (!valIsBool) { return 'first argument is not a boolean; second argument is'; }\n\t\tif (!otherIsBool) { return 'second argument is not a boolean; first argument is'; }\n\t\tvar valBoolVal = booleanValue.call(value);\n\t\tvar otherBoolVal = booleanValue.call(other);\n\t\tif (valBoolVal === otherBoolVal) { return ''; }\n\t\treturn 'primitive value of boolean arguments do not match: ' + valBoolVal + ' !== ' + otherBoolVal;\n\t}\n\n\tvar valIsNumber = isNumber(value);\n\tvar otherIsNumber = isNumber(value);\n\tif (valIsNumber || otherIsNumber) {\n\t\tif (!valIsNumber) { return 'first argument is not a number; second argument is'; }\n\t\tif (!otherIsNumber) { return 'second argument is not a number; first argument is'; }\n\t\tvar valNum = Number(value);\n\t\tvar otherNum = Number(other);\n\t\tif (valNum === otherNum) { return ''; }\n\t\tvar valIsNaN = isNaN(value);\n\t\tvar otherIsNaN = isNaN(other);\n\t\tif (valIsNaN && !otherIsNaN) {\n\t\t\treturn 'first argument is NaN; second is not';\n\t\t} else if (!valIsNaN && otherIsNaN) {\n\t\t\treturn 'second argument is NaN; first is not';\n\t\t} else if (valIsNaN && otherIsNaN) {\n\t\t\treturn '';\n\t\t}\n\t\treturn 'numbers are different: ' + value + ' !== ' + other;\n\t}\n\n\tvar valIsString = isString(value);\n\tvar otherIsString = isString(other);\n\tif (valIsString || otherIsString) {\n\t\tif (!valIsString) { return 'second argument is string; first is not'; }\n\t\tif (!otherIsString) { return 'first argument is string; second is not'; }\n\t\tvar stringVal = String(value);\n\t\tvar otherVal = String(other);\n\t\tif (stringVal === otherVal) { return ''; }\n\t\treturn 'string values are different: \"' + stringVal + '\" !== \"' + otherVal + '\"';\n\t}\n\n\tvar valIsDate = isDate(value);\n\tvar otherIsDate = isDate(other);\n\tif (valIsDate || otherIsDate) {\n\t\tif (!valIsDate) { return 'second argument is Date, first is not'; }\n\t\tif (!otherIsDate) { return 'first argument is Date, second is not'; }\n\t\tvar valTime = +value;\n\t\tvar otherTime = +other;\n\t\tif (valTime === otherTime) { return ''; }\n\t\treturn 'Dates have different time values: ' + valTime + ' !== ' + otherTime;\n\t}\n\n\tvar valIsRegex = isRegex(value);\n\tvar otherIsRegex = isRegex(other);\n\tif (valIsRegex || otherIsRegex) {\n\t\tif (!valIsRegex) { return 'second argument is RegExp, first is not'; }\n\t\tif (!otherIsRegex) { return 'first argument is RegExp, second is not'; }\n\t\tvar regexStringVal = String(value);\n\t\tvar regexStringOther = String(other);\n\t\tif (regexStringVal === regexStringOther) { return ''; }\n\t\treturn 'regular expressions differ: ' + regexStringVal + ' !== ' + regexStringOther;\n\t}\n\n\tvar valIsArray = isArray(value);\n\tvar otherIsArray = isArray(other);\n\tif (valIsArray || otherIsArray) {\n\t\tif (!valIsArray) { return 'second argument is an Array, first is not'; }\n\t\tif (!otherIsArray) { return 'first argument is an Array, second is not'; }\n\t\tif (value.length !== other.length) {\n\t\t\treturn 'arrays have different length: ' + value.length + ' !== ' + other.length;\n\t\t}\n\t\tif (String(value) !== String(other)) { return 'stringified Arrays differ'; }\n\n\t\tvar index = value.length - 1;\n\t\tvar equal = '';\n\t\tvar valHasIndex, otherHasIndex;\n\t\twhile (equal === '' && index >= 0) {\n\t\t\tvalHasIndex = has(value, index);\n\t\t\totherHasIndex = has(other, index);\n\t\t\tif (!valHasIndex && otherHasIndex) { return 'second argument has index ' + index + '; first does not'; }\n\t\t\tif (valHasIndex && !otherHasIndex) { return 'first argument has index ' + index + '; second does not'; }\n\t\t\tequal = whyNotEqual(value[index], other[index]);\n\t\t\tindex -= 1;\n\t\t}\n\t\treturn equal;\n\t}\n\n\tvar valueIsSym = isSymbol(value);\n\tvar otherIsSym = isSymbol(other);\n\tif (valueIsSym !== otherIsSym) {\n\t\tif (valueIsSym) { return 'first argument is Symbol; second is not'; }\n\t\treturn 'second argument is Symbol; first is not';\n\t}\n\tif (valueIsSym && otherIsSym) {\n\t\treturn symbolValue.call(value) === symbolValue.call(other) ? '' : 'first Symbol value !== second Symbol value';\n\t}\n\n\tvar valueIsGen = isGenerator(value);\n\tvar otherIsGen = isGenerator(other);\n\tif (valueIsGen !== otherIsGen) {\n\t\tif (valueIsGen) { return 'first argument is a Generator; second is not'; }\n\t\treturn 'second argument is a Generator; first is not';\n\t}\n\n\tvar valueIsArrow = isArrowFunction(value);\n\tvar otherIsArrow = isArrowFunction(other);\n\tif (valueIsArrow !== otherIsArrow) {\n\t\tif (valueIsArrow) { return 'first argument is an Arrow function; second is not'; }\n\t\treturn 'second argument is an Arrow function; first is not';\n\t}\n\n\tif (isCallable(value) || isCallable(other)) {\n\t\tif (functionsHaveNames && whyNotEqual(value.name, other.name) !== '') {\n\t\t\treturn 'Function names differ: \"' + value.name + '\" !== \"' + other.name + '\"';\n\t\t}\n\t\tif (whyNotEqual(value.length, other.length) !== '') {\n\t\t\treturn 'Function lengths differ: ' + value.length + ' !== ' + other.length;\n\t\t}\n\n\t\tvar valueStr = normalizeFnWhitespace(String(value));\n\t\tvar otherStr = normalizeFnWhitespace(String(other));\n\t\tif (whyNotEqual(valueStr, otherStr) === '') { return ''; }\n\n\t\tif (!valueIsGen && !valueIsArrow) {\n\t\t\treturn whyNotEqual(valueStr.replace(/\\)\\s*\\{/, '){'), otherStr.replace(/\\)\\s*\\{/, '){')) === '' ? '' : 'Function string representations differ';\n\t\t}\n\t\treturn whyNotEqual(valueStr, otherStr) === '' ? '' : 'Function string representations differ';\n\t}\n\n\tif (typeof value === 'object' || typeof other === 'object') {\n\t\tif (typeof value !== typeof other) { return 'arguments have a different typeof: ' + typeof value + ' !== ' + typeof other; }\n\t\tif (isProto.call(value, other)) { return 'first argument is the [[Prototype]] of the second'; }\n\t\tif (isProto.call(other, value)) { return 'second argument is the [[Prototype]] of the first'; }\n\t\tif (getPrototypeOf(value) !== getPrototypeOf(other)) { return 'arguments have a different [[Prototype]]'; }\n\n\t\tif (symbolIterator) {\n\t\t\tvar valueIteratorFn = value[symbolIterator];\n\t\t\tvar valueIsIterable = isCallable(valueIteratorFn);\n\t\t\tvar otherIteratorFn = other[symbolIterator];\n\t\t\tvar otherIsIterable = isCallable(otherIteratorFn);\n\t\t\tif (valueIsIterable !== otherIsIterable) {\n\t\t\t\tif (valueIsIterable) { return 'first argument is iterable; second is not'; }\n\t\t\t\treturn 'second argument is iterable; first is not';\n\t\t\t}\n\t\t\tif (valueIsIterable && otherIsIterable) {\n\t\t\t\tvar valueIterator = valueIteratorFn.call(value);\n\t\t\t\tvar otherIterator = otherIteratorFn.call(other);\n\t\t\t\tvar valueNext, otherNext, nextWhy;\n\t\t\t\tdo {\n\t\t\t\t\tvalueNext = valueIterator.next();\n\t\t\t\t\totherNext = otherIterator.next();\n\t\t\t\t\tif (!valueNext.done && !otherNext.done) {\n\t\t\t\t\t\tnextWhy = whyNotEqual(valueNext, otherNext);\n\t\t\t\t\t\tif (nextWhy !== '') {\n\t\t\t\t\t\t\treturn 'iteration results are not equal: ' + nextWhy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (!valueNext.done && !otherNext.done);\n\t\t\t\tif (valueNext.done && !otherNext.done) { return 'first argument finished iterating before second'; }\n\t\t\t\tif (!valueNext.done && otherNext.done) { return 'second argument finished iterating before first'; }\n\t\t\t\treturn '';\n\t\t\t}\n\t\t} else if (collectionsForEach.Map || collectionsForEach.Set) {\n\t\t\tvar valueEntries = tryMapSetEntries(value);\n\t\t\tvar otherEntries = tryMapSetEntries(other);\n\t\t\tvar valueEntriesIsArray = isArray(valueEntries);\n\t\t\tvar otherEntriesIsArray = isArray(otherEntries);\n\t\t\tif (valueEntriesIsArray && !otherEntriesIsArray) { return 'first argument has Collection entries, second does not'; }\n\t\t\tif (!valueEntriesIsArray && otherEntriesIsArray) { return 'second argument has Collection entries, first does not'; }\n\t\t\tif (valueEntriesIsArray && otherEntriesIsArray) {\n\t\t\t\tvar entriesWhy = whyNotEqual(valueEntries, otherEntries);\n\t\t\t\treturn entriesWhy === '' ? '' : 'Collection entries differ: ' + entriesWhy;\n\t\t\t}\n\t\t}\n\n\t\tvar key, valueKeyIsRecursive, otherKeyIsRecursive, keyWhy;\n\t\tfor (key in value) {\n\t\t\tif (has(value, key)) {\n\t\t\t\tif (!has(other, key)) { return 'first argument has key \"' + key + '\"; second does not'; }\n\t\t\t\tvalueKeyIsRecursive = !!value[key] && value[key][key] === value;\n\t\t\t\totherKeyIsRecursive = !!other[key] && other[key][key] === other;\n\t\t\t\tif (valueKeyIsRecursive !== otherKeyIsRecursive) {\n\t\t\t\t\tif (valueKeyIsRecursive) { return 'first argument has a circular reference at key \"' + key + '\"; second does not'; }\n\t\t\t\t\treturn 'second argument has a circular reference at key \"' + key + '\"; first does not';\n\t\t\t\t}\n\t\t\t\tif (!valueKeyIsRecursive && !otherKeyIsRecursive) {\n\t\t\t\t\tkeyWhy = whyNotEqual(value[key], other[key]);\n\t\t\t\t\tif (keyWhy !== '') {\n\t\t\t\t\t\treturn 'value at key \"' + key + '\" differs: ' + keyWhy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (key in other) {\n\t\t\tif (has(other, key) && !has(value, key)) {\n\t\t\t\treturn 'second argument has key \"' + key + '\"; first does not';\n\t\t\t}\n\t\t}\n\t\treturn '';\n\t}\n\n\treturn false;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/is-equal/why.js\n// module id = 23\n// module chunks = 0","'use strict';\n\nvar isCallable = require('is-callable');\nvar fnToStr = Function.prototype.toString;\nvar isNonArrowFnRegex = /^\\s*function/;\nvar isArrowFnWithParensRegex = /^\\([^\\)]*\\) *=>/;\nvar isArrowFnWithoutParensRegex = /^[^=]*=>/;\n\nmodule.exports = function isArrowFunction(fn) {\n\tif (!isCallable(fn)) { return false; }\n\tvar fnStr = fnToStr.call(fn);\n\treturn fnStr.length > 0 &&\n\t\t!isNonArrowFnRegex.test(fnStr) &&\n\t\t(isArrowFnWithParensRegex.test(fnStr) || isArrowFnWithoutParensRegex.test(fnStr));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/is-arrow-function/index.js\n// module id = 24\n// module chunks = 0","'use strict';\n\nvar fnToStr = Function.prototype.toString;\n\nvar constructorRegex = /^\\s*class /;\nvar isES6ClassFn = function isES6ClassFn(value) {\n\ttry {\n\t\tvar fnStr = fnToStr.call(value);\n\t\tvar singleStripped = fnStr.replace(/\\/\\/.*\\n/g, '');\n\t\tvar multiStripped = singleStripped.replace(/\\/\\*[.\\s\\S]*\\*\\//g, '');\n\t\tvar spaceStripped = multiStripped.replace(/\\n/mg, ' ').replace(/ {2}/g, ' ');\n\t\treturn constructorRegex.test(spaceStripped);\n\t} catch (e) {\n\t\treturn false; // not a function\n\t}\n};\n\nvar tryFunctionObject = function tryFunctionObject(value) {\n\ttry {\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tfnToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar fnClass = '[object Function]';\nvar genClass = '[object GeneratorFunction]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isCallable(value) {\n\tif (!value) { return false; }\n\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\tif (hasToStringTag) { return tryFunctionObject(value); }\n\tif (isES6ClassFn(value)) { return false; }\n\tvar strClass = toStr.call(value);\n\treturn strClass === fnClass || strClass === genClass;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/is-callable/index.js\n// module id = 25\n// module chunks = 0","'use strict';\n\nvar boolToStr = Boolean.prototype.toString;\n\nvar tryBooleanObject = function tryBooleanObject(value) {\n\ttry {\n\t\tboolToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar boolClass = '[object Boolean]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isBoolean(value) {\n\tif (typeof value === 'boolean') { return true; }\n\tif (typeof value !== 'object') { return false; }\n\treturn hasToStringTag ? tryBooleanObject(value) : toStr.call(value) === boolClass;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/is-boolean-object/index.js\n// module id = 26\n// module chunks = 0","'use strict';\n\nvar getDay = Date.prototype.getDay;\nvar tryDateObject = function tryDateObject(value) {\n\ttry {\n\t\tgetDay.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\nvar toStr = Object.prototype.toString;\nvar dateClass = '[object Date]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isDateObject(value) {\n\tif (typeof value !== 'object' || value === null) { return false; }\n\treturn hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/is-date-object/index.js\n// module id = 27\n// module chunks = 0","'use strict';\n\nvar toStr = Object.prototype.toString;\nvar fnToStr = Function.prototype.toString;\nvar isFnRegex = /^\\s*(?:function)?\\*/;\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\nvar getProto = Object.getPrototypeOf;\nvar getGeneratorFunc = function () { // eslint-disable-line consistent-return\n\tif (!hasToStringTag) {\n\t\treturn false;\n\t}\n\ttry {\n\t\treturn Function('return function*() {}')();\n\t} catch (e) {\n\t}\n};\nvar generatorFunc = getGeneratorFunc();\nvar GeneratorFunction = generatorFunc ? getProto(generatorFunc) : {};\n\nmodule.exports = function isGeneratorFunction(fn) {\n\tif (typeof fn !== 'function') {\n\t\treturn false;\n\t}\n\tif (isFnRegex.test(fnToStr.call(fn))) {\n\t\treturn true;\n\t}\n\tif (!hasToStringTag) {\n\t\tvar str = toStr.call(fn);\n\t\treturn str === '[object GeneratorFunction]';\n\t}\n\treturn getProto(fn) === GeneratorFunction;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/is-generator-function/index.js\n// module id = 28\n// module chunks = 0","'use strict';\n\nvar numToStr = Number.prototype.toString;\nvar tryNumberObject = function tryNumberObject(value) {\n\ttry {\n\t\tnumToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar numClass = '[object Number]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isNumberObject(value) {\n\tif (typeof value === 'number') { return true; }\n\tif (typeof value !== 'object') { return false; }\n\treturn hasToStringTag ? tryNumberObject(value) : toStr.call(value) === numClass;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/is-number-object/index.js\n// module id = 29\n// module chunks = 0","'use strict';\n\nvar strValue = String.prototype.valueOf;\nvar tryStringObject = function tryStringObject(value) {\n\ttry {\n\t\tstrValue.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar strClass = '[object String]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isString(value) {\n\tif (typeof value === 'string') { return true; }\n\tif (typeof value !== 'object') { return false; }\n\treturn hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/is-string/index.js\n// module id = 30\n// module chunks = 0","'use strict';\n\nvar toStr = Object.prototype.toString;\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';\n\nif (hasSymbols) {\n\tvar symToStr = Symbol.prototype.toString;\n\tvar symStringRegex = /^Symbol\\(.*\\)$/;\n\tvar isSymbolObject = function isSymbolObject(value) {\n\t\tif (typeof value.valueOf() !== 'symbol') { return false; }\n\t\treturn symStringRegex.test(symToStr.call(value));\n\t};\n\tmodule.exports = function isSymbol(value) {\n\t\tif (typeof value === 'symbol') { return true; }\n\t\tif (toStr.call(value) !== '[object Symbol]') { return false; }\n\t\ttry {\n\t\t\treturn isSymbolObject(value);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n} else {\n\tmodule.exports = function isSymbol(value) {\n\t\t// this environment does not support Symbols.\n\t\treturn false;\n\t};\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/is-symbol/index.js\n// module id = 31\n// module chunks = 0","'use strict';\n\nvar isSymbol = require('is-symbol');\n\nmodule.exports = function getSymbolIterator() {\n\tvar symbolIterator = typeof Symbol === 'function' && isSymbol(Symbol.iterator) ? Symbol.iterator : null;\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && typeof Map === 'function' && typeof Map.prototype.entries === 'function') {\n\t\tObject.getOwnPropertyNames(Map.prototype).forEach(function (name) {\n\t\t\tif (name !== 'entries' && name !== 'size' && Map.prototype[name] === Map.prototype.entries) {\n\t\t\t\tsymbolIterator = name;\n\t\t\t}\n\t\t});\n\t}\n\n\treturn symbolIterator;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/is-equal/getSymbolIterator.js\n// module id = 32\n// module chunks = 0","'use strict';\n\nmodule.exports = function () {\n\tvar mapForEach = (function () {\n\t\tif (typeof Map !== 'function') { return null; }\n\t\ttry {\n\t\t\tMap.prototype.forEach.call({}, function () {});\n\t\t} catch (e) {\n\t\t\treturn Map.prototype.forEach;\n\t\t}\n\t\treturn null;\n\t}());\n\n\tvar setForEach = (function () {\n\t\tif (typeof Set !== 'function') { return null; }\n\t\ttry {\n\t\t\tSet.prototype.forEach.call({}, function () {});\n\t\t} catch (e) {\n\t\t\treturn Set.prototype.forEach;\n\t\t}\n\t\treturn null;\n\t}());\n\n\treturn { Map: mapForEach, Set: setForEach };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/is-equal/getCollectionsForEach.js\n// module id = 33\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Expectation = require('./Expectation');\n\nvar _Expectation2 = _interopRequireDefault(_Expectation);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Extensions = [];\n\nfunction extend(extension) {\n  if (Extensions.indexOf(extension) === -1) {\n    Extensions.push(extension);\n\n    for (var p in extension) {\n      if (extension.hasOwnProperty(p)) _Expectation2.default.prototype[p] = extension[p];\n    }\n  }\n}\n\nexports.default = extend;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/expect/lib/extend.js\n// module id = 34\n// module chunks = 0"],"sourceRoot":""}